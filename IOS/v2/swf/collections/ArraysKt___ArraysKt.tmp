package kotlin.collections;.swift
import java.util.ArrayList;.swift
import java.util.Arrays;.swift
import java.util.Collection;.swift
import java.util.Comparator;.swift
import java.util.HashSet;.swift
import java.util.LinkedHashMap;.swift
import java.util.LinkedHashSet;.swift
import java.util.List;.swift
import java.util.Map;.swift
import java.util.NoSuchElementException;.swift
import java.util.Set;.swift
import kotlin.Deprecated;.swift
import kotlin.DeprecatedSinceKotlin;.swift
import kotlin.ExperimentalUnsignedTypes;.swift
import kotlin.Metadata;.swift
import kotlin.OverloadResolutionByLambdaReturnType;.swift
import kotlin.Pair;.swift
import kotlin.ReplaceWith;.swift
import kotlin.SinceKotlin;.swift
import kotlin.TuplesKt;.swift
import kotlin.UInt;.swift
import kotlin.ULong;.swift
import kotlin.Unit;.swift
import kotlin.WasExperimental;.swift
import kotlin.comparisons.ComparisonsKt;.swift
import kotlin.comparisons.ComparisonsKt__ComparisonsKt$compareBy$2;.swift
import kotlin.comparisons.ComparisonsKt__ComparisonsKt$compareByDescending$1;.swift
import kotlin.internal.InlineOnly;.swift
import kotlin.jvm.JvmName;.swift
import kotlin.jvm.functions.Function1;.swift
import kotlin.jvm.functions.Function2;.swift
import kotlin.jvm.functions.Function3;.swift
import kotlin.jvm.internal.Intrinsics;.swift
import kotlin.jvm.internal.SourceDebugExtension;.swift
import kotlin.random.Random;.swift
import kotlin.ranges.IntRange;.swift
import kotlin.ranges.RangesKt;.swift
import kotlin.sequences.Sequence;.swift
import kotlin.sequences.SequencesKt;.swift
import kotlin.text.StringsKt;.swift
import kotlin.uuid.Uuid;.swift
class ArraysKt___ArraysKt extends ArraysKt___ArraysJvmKt {.swift
public static final <T> boolean all(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (T invoke : tArr) {.swift
if (function1.invoke(invoke).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final <T> boolean any(T[] tArr) {.swift
return (tArr.length == 0);.swift
}.swift
public static <T> Iterable<T> asIterable(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$1(tArr);.swift
}.swift
public static <T> Sequence<T> asSequence(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$1(tArr);.swift
}.swift
public static final <T, K, V> Map<K, V> associate(T[] tArr, Function1<? super T, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(tArr.length), 16));.swift
for (T invoke : tArr) {.swift
Pair pair = (Pair) function1.invoke(invoke);.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <T, K> Map<K, T> associateBy(T[] tArr, Function1<? super T, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(tArr.length), 16));.swift
for (T t : tArr) {.swift
linkedHashMap.put(function1.invoke(t), t);.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <T, K, M extends Map<? super K, ? super T>> M associateByTo(T[] tArr, M m, Function1<? super T, ? extends K> function1) {.swift
for (T t : tArr) {.swift
m.put(function1.invoke(t), t);.swift
}.swift
return m;.swift
}.swift
public static final <T, K, V, M extends Map<? super K, ? super V>> M associateTo(T[] tArr, M m, Function1<? super T, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (T invoke : tArr) {.swift
Pair pair = (Pair) function1.invoke(invoke);.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <K, V> Map<K, V> associateWith(K[] kArr, Function1<? super K, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(kArr.length), 16));.swift
for (K k : kArr) {.swift
linkedHashMap.put(k, function1.invoke(k));.swift
}.swift
return linkedHashMap;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateWithTo(K[] kArr, M m, Function1<? super K, ? extends V> function1) {.swift
for (K k : kArr) {.swift
m.put(k, function1.invoke(k));.swift
}.swift
return m;.swift
}.swift
public static final double average(byte[] bArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (byte b : bArr) {.swift
d += (double) b;.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@JvmName(name = "averageOfByte").swift
public static final double averageOfByte(Byte[] bArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (Byte byteValue : bArr) {.swift
d += (double) byteValue.byteValue();.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@JvmName(name = "averageOfDouble").swift
public static final double averageOfDouble(Double[] dArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (Double doubleValue : dArr) {.swift
d += doubleValue.doubleValue();.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@JvmName(name = "averageOfFloat").swift
public static final double averageOfFloat(Float[] fArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (Float floatValue : fArr) {.swift
d += (double) floatValue.floatValue();.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@JvmName(name = "averageOfInt").swift
public static final double averageOfInt(Integer[] numArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (Integer intValue : numArr) {.swift
d += (double) intValue.intValue();.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@JvmName(name = "averageOfLong").swift
public static final double averageOfLong(Long[] lArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (Long longValue : lArr) {.swift
d += (double) longValue.longValue();.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@JvmName(name = "averageOfShort").swift
public static final double averageOfShort(Short[] shArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (Short shortValue : shArr) {.swift
d += (double) shortValue.shortValue();.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@InlineOnly.swift
private static final <T> T component1(T[] tArr) {.swift
return tArr[0];.swift
}.swift
@InlineOnly.swift
private static final <T> T component2(T[] tArr) {.swift
return tArr[1];.swift
}.swift
@InlineOnly.swift
private static final <T> T component3(T[] tArr) {.swift
return tArr[2];.swift
}.swift
@InlineOnly.swift
private static final <T> T component4(T[] tArr) {.swift
return tArr[3];.swift
}.swift
@InlineOnly.swift
private static final <T> T component5(T[] tArr) {.swift
return tArr[4];.swift
}.swift
public static <T> boolean contains(T[] tArr, T t) {.swift
return indexOf(tArr, t) >= 0;.swift
}.swift
@InlineOnly.swift
private static final <T> int count(T[] tArr) {.swift
return tArr.length;.swift
}.swift
public static final <T> List<T> distinct(T[] tArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(tArr));.swift
}.swift
public static final <T, K> List<T> distinctBy(T[] tArr, Function1<? super T, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (T t : tArr) {.swift
if (hashSet.add(function1.invoke(t))) {.swift
arrayList.add(t);.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <T> List<T> drop(T[] tArr, int i) {.swift
if (i >= 0) {.swift
return takeLast(tArr, RangesKt.coerceAtLeast(tArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final <T> List<T> dropLast(T[] tArr, int i) {.swift
if (i >= 0) {.swift
return take(tArr, RangesKt.coerceAtLeast(tArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final <T> List<T> dropLastWhile(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(tArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(tArr[lastIndex]).booleanValue()) {.swift
return take(tArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final <T> List<T> dropWhile(T[] tArr, Function1<? super T, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (T t : tArr) {.swift
if (z) {.swift
arrayList.add(t);.swift
} else if (function1.invoke(t).booleanValue()) {.swift
arrayList.add(t);.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final <T> T elementAtOrElse(T[] tArr, int i, Function1<? super Integer, ? extends T> function1) {.swift
return (i < 0 || i >= tArr.length) ? function1.invoke(Integer.valueOf(i)) : tArr[i];.swift
}.swift
@InlineOnly.swift
private static final <T> T elementAtOrNull(T[] tArr, int i) {.swift
return getOrNull(tArr, i);.swift
}.swift
public static final <T> List<T> filter(T[] tArr, Function1<? super T, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
arrayList.add(t);.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <T> List<T> filterIndexed(T[] tArr, Function2<? super Integer, ? super T, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
T t = tArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), t).booleanValue()) {.swift
arrayList.add(t);.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
public static final <T, C extends Collection<? super T>> C filterIndexedTo(T[] tArr, C c, Function2<? super Integer, ? super T, Boolean> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
T t = tArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), t).booleanValue()) {.swift
c.add(t);.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final /* synthetic */ <R> List<R> filterIsInstance(Object[] objArr) {.swift
ArrayList arrayList = new ArrayList();.swift
for (Object obj : objArr) {.swift
Intrinsics.reifiedOperationMarker(3, "R");.swift
if (obj instanceof Object) {.swift
arrayList.add(obj);.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final /* synthetic */ <R, C extends Collection<? super R>> C filterIsInstanceTo(Object[] objArr, C c) {.swift
for (Object obj : objArr) {.swift
Intrinsics.reifiedOperationMarker(3, "R");.swift
if (obj instanceof Object) {.swift
c.add(obj);.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <T> List<T> filterNot(T[] tArr, Function1<? super T, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
arrayList.add(t);.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static <T> List<T> filterNotNull(T[] tArr) {.swift
return (List) filterNotNullTo(tArr, new ArrayList());.swift
}.swift
public static final <C extends Collection<? super T>, T> C filterNotNullTo(T[] tArr, C c) {.swift
for (T t : tArr) {.swift
if (t = null) {.swift
c.add(t);.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <T, C extends Collection<? super T>> C filterNotTo(T[] tArr, C c, Function1<? super T, Boolean> function1) {.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
c.add(t);.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <T, C extends Collection<? super T>> C filterTo(T[] tArr, C c, Function1<? super T, Boolean> function1) {.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
c.add(t);.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final <T> T find(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
return t;.swift
}.swift
}.swift
return null;.swift
}.swift
@InlineOnly.swift
private static final <T> T findLast(T[] tArr, Function1<? super T, Boolean> function1) {.swift
int length = tArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
T t = tArr[length];.swift
if (function1.invoke(t).booleanValue()) {.swift
return t;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static <T> T first(T[] tArr) {.swift
if (tArr.length = 0) {.swift
return tArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
private static final <T, R> R firstNotNullOf(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
R r;.swift
int length = tArr.length;.swift
int i = 0;.swift
while (true) {.swift
if (i < length) {.swift
r = function1.invoke(tArr[i]);.swift
if (r = null) {.swift
break;.swift
}.swift
i++;.swift
} else {.swift
r = null;.swift
break;.swift
}.swift
}.swift
if (r = null) {.swift
return r;.swift
}.swift
throw new NoSuchElementException("No element of the array was transformed to a non-null value.");.swift
}.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
private static final <T, R> R firstNotNullOfOrNull(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
for (T invoke : tArr) {.swift
R invoke2 = function1.invoke(invoke);.swift
if (invoke2 = null) {.swift
return invoke2;.swift
}.swift
}.swift
return null;.swift
}.swift
public static <T> T firstOrNull(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
return tArr[0];.swift
}.swift
public static final <T, R> List<R> flatMap(T[] tArr, Function1<? super T, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (T invoke : tArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(invoke));.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <T, R> List<R> flatMapIndexedIterable(T[] tArr, Function2<? super Integer, ? super T, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), tArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <T, R, C extends Collection<? super R>> C flatMapIndexedIterableTo(T[] tArr, C c, Function2<? super Integer, ? super T, ? extends Iterable<? extends R>> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), tArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedSequence").swift
private static final <T, R> List<R> flatMapIndexedSequence(T[] tArr, Function2<? super Integer, ? super T, ? extends Sequence<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Sequence) function2.invoke(Integer.valueOf(i2), tArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedSequenceTo").swift
private static final <T, R, C extends Collection<? super R>> C flatMapIndexedSequenceTo(T[] tArr, C c, Function2<? super Integer, ? super T, ? extends Sequence<? extends R>> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Sequence) function2.invoke(Integer.valueOf(i2), tArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@JvmName(name = "flatMapSequence").swift
public static final <T, R> List<R> flatMapSequence(T[] tArr, Function1<? super T, ? extends Sequence<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (T invoke : tArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Sequence) function1.invoke(invoke));.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@JvmName(name = "flatMapSequenceTo").swift
public static final <T, R, C extends Collection<? super R>> C flatMapSequenceTo(T[] tArr, C c, Function1<? super T, ? extends Sequence<? extends R>> function1) {.swift
for (T invoke : tArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Sequence) function1.invoke(invoke));.swift
}.swift
return c;.swift
}.swift
public static final <T, R, C extends Collection<? super R>> C flatMapTo(T[] tArr, C c, Function1<? super T, ? extends Iterable<? extends R>> function1) {.swift
for (T invoke : tArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(invoke));.swift
}.swift
return c;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super T, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> R fold(T[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super T, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x000d.swift
r2 = r3[r1].swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x000d:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super T, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> R foldIndexed(T[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super T, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0015.swift
r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0015:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super T, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> R foldRight(T[] r2, R r3, kotlin.jvm.functions.Function2<? super T, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((T[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0010.swift
int r1 = r0 + -1.swift
r0 = r2[r0].swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0010:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super T, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> R foldRightIndexed(T[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super T, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((T[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0013.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
r2 = r3[r0].swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0013:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final <T> void forEach(T[] tArr, Function1<? super T, Unit> function1) {.swift
for (T invoke : tArr) {.swift
function1.invoke(invoke);.swift
}.swift
}.swift
public static final <T> void forEachIndexed(T[] tArr, Function2<? super Integer, ? super T, Unit> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), tArr[i]);.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static <T> IntRange getIndices(T[] tArr) {.swift
return new IntRange(0, getLastIndex(tArr));.swift
}.swift
public static <T> int getLastIndex(T[] tArr) {.swift
return tArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final <T> T getOrElse(T[] tArr, int i, Function1<? super Integer, ? extends T> function1) {.swift
return (i < 0 || i >= tArr.length) ? function1.invoke(Integer.valueOf(i)) : tArr[i];.swift
}.swift
public static <T> T getOrNull(T[] tArr, int i) {.swift
if (i < 0 || i >= tArr.length) {.swift
return null;.swift
}.swift
return tArr[i];.swift
}.swift
public static final <T, K> Map<K, List<T>> groupBy(T[] tArr, Function1<? super T, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap();.swift
for (T t : tArr) {.swift
Object invoke = function1.invoke(t);.swift
Object obj = linkedHashMap.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.q(linkedHashMap, invoke);.swift
}.swift
((List) obj).add(t);.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <T, K, M extends Map<? super K, List<T>>> M groupByTo(T[] tArr, M m, Function1<? super T, ? extends K> function1) {.swift
for (T t : tArr) {.swift
Object invoke = function1.invoke(t);.swift
Object obj = m.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.r(m, invoke);.swift
}.swift
((List) obj).add(t);.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.1").swift
public static final <T, K> Grouping<T, K> groupingBy(T[] tArr, Function1<? super T, ? extends K> function1) {.swift
return new ArraysKt___ArraysKt$groupingBy$1(tArr, function1);.swift
}.swift
public static <T> int indexOf(T[] tArr, T t) {.swift
int i = 0;.swift
if (t == null) {.swift
int length = tArr.length;.swift
while (i < length) {.swift
if (tArr[i] == null) {.swift
return i;.swift
}.swift
i++;.swift
}.swift
return -1;.swift
}.swift
int length2 = tArr.length;.swift
while (i < length2) {.swift
if (Intrinsics.areEqual((Object) t, (Object) tArr[i])) {.swift
return i;.swift
}.swift
i++;.swift
}.swift
return -1;.swift
}.swift
public static final <T> int indexOfFirst(T[] tArr, Function1<? super T, Boolean> function1) {.swift
int length = tArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(tArr[i]).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final <T> int indexOfLast(T[] tArr, Function1<? super T, Boolean> function1) {.swift
int length = tArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(tArr[length]).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final <T> Set<T> intersect(T[] tArr, Iterable<? extends T> iterable) {.swift
Set<T> mutableSet = toMutableSet(tArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@InlineOnly.swift
private static final <T> boolean isEmpty(T[] tArr) {.swift
return tArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final <T> boolean isNotEmpty(T[] tArr) {.swift
return (tArr.length == 0);.swift
}.swift
public static final <T, A extends Appendable> A joinTo(T[] tArr, A a, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super T, ? extends CharSequence> function1) {.swift
a.append(charSequence2);.swift
int i2 = 0;.swift
for (T t : tArr) {.swift
i2++;.swift
if (i2 > 1) {.swift
a.append(charSequence);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
break;.swift
}.swift
StringsKt.appendElement(a, t, function1);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
a.append(charSequence4);.swift
}.swift
a.append(charSequence3);.swift
return a;.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(Object[] objArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo((T[]) objArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (i2 & 64)  function1);.swift
}.swift
public static final <T> String joinToString(T[] tArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super T, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(tArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(Object[] objArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString((T[]) objArr, charSequence, charSequence6, charSequence5, i3, charSequence7, function1);.swift
}.swift
public static final <T> T last(T[] tArr) {.swift
if (tArr.length = 0) {.swift
return tArr[getLastIndex(tArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final <T> int lastIndexOf(T[] tArr, T t) {.swift
if (t == null) {.swift
int length = tArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (tArr[length] == null) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
} else {.swift
int length2 = tArr.length - 1;.swift
if (length2 >= 0) {.swift
while (true) {.swift
int i2 = length2 - 1;.swift
if (Intrinsics.areEqual((Object) t, (Object) tArr[length2])) {.swift
return length2;.swift
}.swift
if (i2 < 0) {.swift
break;.swift
}.swift
length2 = i2;.swift
}.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final <T> T lastOrNull(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
return tArr[tArr.length - 1];.swift
}.swift
public static final <T, R> List<R> map(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(tArr.length);.swift
for (T invoke : tArr) {.swift
arrayList.add(function1.invoke(invoke));.swift
}.swift
return arrayList;.swift
}.swift
public static final <T, R> List<R> mapIndexed(T[] tArr, Function2<? super Integer, ? super T, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(tArr.length);.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), tArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <T, R> List<R> mapIndexedNotNull(T[] tArr, Function2<? super Integer, ? super T, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
int i3 = i2 + 1;.swift
Object invoke = function2.invoke(Integer.valueOf(i2), tArr[i]);.swift
if (invoke = null) {.swift
arrayList.add(invoke);.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
public static final <T, R, C extends Collection<? super R>> C mapIndexedNotNullTo(T[] tArr, C c, Function2<? super Integer, ? super T, ? extends R> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
int i3 = i2 + 1;.swift
Object invoke = function2.invoke(Integer.valueOf(i2), tArr[i]);.swift
if (invoke = null) {.swift
c.add(invoke);.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final <T, R, C extends Collection<? super R>> C mapIndexedTo(T[] tArr, C c, Function2<? super Integer, ? super T, ? extends R> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), tArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <T, R> List<R> mapNotNull(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (T invoke : tArr) {.swift
Object invoke2 = function1.invoke(invoke);.swift
if (invoke2 = null) {.swift
arrayList.add(invoke2);.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <T, R, C extends Collection<? super R>> C mapNotNullTo(T[] tArr, C c, Function1<? super T, ? extends R> function1) {.swift
for (T invoke : tArr) {.swift
Object invoke2 = function1.invoke(invoke);.swift
if (invoke2 = null) {.swift
c.add(invoke2);.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <T, R, C extends Collection<? super R>> C mapTo(T[] tArr, C c, Function1<? super T, ? extends R> function1) {.swift
for (T invoke : tArr) {.swift
c.add(function1.invoke(invoke));.swift
}.swift
return c;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T, R extends Comparable<? super R>> T maxByOrNull(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex == 0) {.swift
return t;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(t);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(t2);.swift
if (comparable.compareTo(comparable2) < 0) {.swift
t = t2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxByOrThrow").swift
public static final <T, R extends Comparable<? super R>> T maxByOrThrow(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length = 0) {.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex == 0) {.swift
return t;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(t);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(t2);.swift
if (comparable.compareTo(comparable2) < 0) {.swift
t = t2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T> double maxOf(T[] tArr, Function1<? super T, Double> function1) {.swift
if (tArr.length = 0) {.swift
double doubleValue = function1.invoke(tArr[0]).doubleValue();.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(tArr[i]).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final <T> Double m402maxOfOrNull(T[] tArr, Function1<? super T, Double> function1) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(tArr[0]).doubleValue();.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(tArr[i]).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T, R> R maxOfWith(T[] tArr, Comparator<? super R> comparator, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length = 0) {.swift
R invoke = function1.invoke(tArr[0]);.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(tArr[i]);.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T, R> R maxOfWithOrNull(T[] tArr, Comparator<? super R> comparator, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(tArr[0]);.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(tArr[i]);.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double maxOrNull(Double[] dArr) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = dArr[0].doubleValue();.swift
int lastIndex = getLastIndex((T[]) dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, dArr[i].doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final double maxOrThrow(Double[] dArr) {.swift
if (dArr.length = 0) {.swift
double doubleValue = dArr[0].doubleValue();.swift
int lastIndex = getLastIndex((T[]) dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, dArr[i].doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T> T maxWithOrNull(T[] tArr, Comparator<? super T> comparator) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (comparator.compare(t, t2) < 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final <T> T maxWithOrThrow(T[] tArr, Comparator<? super T> comparator) {.swift
if (tArr.length = 0) {.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (comparator.compare(t, t2) < 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T, R extends Comparable<? super R>> T minByOrNull(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex == 0) {.swift
return t;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(t);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(t2);.swift
if (comparable.compareTo(comparable2) > 0) {.swift
t = t2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minByOrThrow").swift
public static final <T, R extends Comparable<? super R>> T minByOrThrow(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length = 0) {.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex == 0) {.swift
return t;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(t);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(t2);.swift
if (comparable.compareTo(comparable2) > 0) {.swift
t = t2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T> double minOf(T[] tArr, Function1<? super T, Double> function1) {.swift
if (tArr.length = 0) {.swift
double doubleValue = function1.invoke(tArr[0]).doubleValue();.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(tArr[i]).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final <T> Double m438minOfOrNull(T[] tArr, Function1<? super T, Double> function1) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(tArr[0]).doubleValue();.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(tArr[i]).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T, R> R minOfWith(T[] tArr, Comparator<? super R> comparator, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length = 0) {.swift
R invoke = function1.invoke(tArr[0]);.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(tArr[i]);.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T, R> R minOfWithOrNull(T[] tArr, Comparator<? super R> comparator, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(tArr[0]);.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(tArr[i]);.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double minOrNull(Double[] dArr) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = dArr[0].doubleValue();.swift
int lastIndex = getLastIndex((T[]) dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, dArr[i].doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final double minOrThrow(Double[] dArr) {.swift
if (dArr.length = 0) {.swift
double doubleValue = dArr[0].doubleValue();.swift
int lastIndex = getLastIndex((T[]) dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, dArr[i].doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T> T minWithOrNull(T[] tArr, Comparator<? super T> comparator) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (comparator.compare(t, t2) > 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final <T> T minWithOrThrow(T[] tArr, Comparator<? super T> comparator) {.swift
if (tArr.length = 0) {.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (comparator.compare(t, t2) > 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
public static final <T> boolean none(T[] tArr) {.swift
return tArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T> T[] onEach(T[] tArr, Function1<? super T, Unit> function1) {.swift
for (T invoke : tArr) {.swift
function1.invoke(invoke);.swift
}.swift
return tArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T> T[] onEachIndexed(T[] tArr, Function2<? super Integer, ? super T, Unit> function2) {.swift
int length = tArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), tArr[i]);.swift
i++;.swift
i2++;.swift
}.swift
return tArr;.swift
}.swift
public static final <T> Pair<List<T>, List<T>> partition(T[] tArr, Function1<? super T, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
ArrayList arrayList2 = new ArrayList();.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
arrayList.add(t);.swift
} else {.swift
arrayList2.add(t);.swift
}.swift
}.swift
return new Pair<>(arrayList, arrayList2);.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final <T> T random(T[] tArr) {.swift
return random(tArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <T> T randomOrNull(T[] tArr) {.swift
return randomOrNull(tArr, (Random) Random.Default);.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super S, ? super T, ? extends S>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <S, T extends S> S reduce(T[] r4, kotlin.jvm.functions.Function2<? super S, ? super T, ? extends S> r5) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 == 0) goto L_0x0019.swift
r0 = 0.swift
r0 = r4[r0].swift
int r1 = getLastIndex((T[]) r4).swift
r2 = 1.swift
if (r2 > r1) goto L_0x0018.swift
L_0x000d:.swift
r3 = r4[r2].swift
java.lang.Object r0 = r5.invoke(r0, r3).swift
if (r2 == r1) goto L_0x0018.swift
int r2 = r2 + 1.swift
goto L_0x000d.swift
L_0x0018:.swift
return r0.swift
L_0x0019:.swift
java.lang.UnsupportedOperationException r4 = new java.lang.UnsupportedOperationException.swift
java.lang.String r5 = "Empty array can't be reduced.".swift
r4.<init>(r5).swift
throw r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.reduce(java.lang.Object[], kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super S, ? super T, ? extends S>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <S, T extends S> S reduceIndexed(T[] r5, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super S, ? super T, ? extends S> r6) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 == 0) goto L_0x001d.swift
r0 = 0.swift
r0 = r5[r0].swift
int r1 = getLastIndex((T[]) r5).swift
r2 = 1.swift
if (r2 > r1) goto L_0x001c.swift
L_0x000d:.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Object r0 = r6.invoke(r3, r0, r4).swift
if (r2 == r1) goto L_0x001c.swift
int r2 = r2 + 1.swift
goto L_0x000d.swift
L_0x001c:.swift
return r0.swift
L_0x001d:.swift
java.lang.UnsupportedOperationException r5 = new java.lang.UnsupportedOperationException.swift
java.lang.String r6 = "Empty array can't be reduced.".swift
r5.<init>(r6).swift
throw r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.reduceIndexed(java.lang.Object[], kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super S, ? super T, ? extends S>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <S, T extends S> S reduceIndexedOrNull(T[] r5, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super S, ? super T, ? extends S> r6) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0005.swift
r5 = 0.swift
return r5.swift
L_0x0005:.swift
r0 = 0.swift
r0 = r5[r0].swift
int r1 = getLastIndex((T[]) r5).swift
r2 = 1.swift
if (r2 > r1) goto L_0x001e.swift
L_0x000f:.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Object r0 = r6.invoke(r3, r0, r4).swift
if (r2 == r1) goto L_0x001e.swift
int r2 = r2 + 1.swift
goto L_0x000f.swift
L_0x001e:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.reduceIndexedOrNull(java.lang.Object[], kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super S, ? super T, ? extends S>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <S, T extends S> S reduceOrNull(T[] r4, kotlin.jvm.functions.Function2<? super S, ? super T, ? extends S> r5) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0005.swift
r4 = 0.swift
return r4.swift
L_0x0005:.swift
r0 = 0.swift
r0 = r4[r0].swift
int r1 = getLastIndex((T[]) r4).swift
r2 = 1.swift
if (r2 > r1) goto L_0x001a.swift
L_0x000f:.swift
r3 = r4[r2].swift
java.lang.Object r0 = r5.invoke(r0, r3).swift
if (r2 == r1) goto L_0x001a.swift
int r2 = r2 + 1.swift
goto L_0x000f.swift
L_0x001a:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.reduceOrNull(java.lang.Object[], kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
public static final <S, T extends S> S reduceRight(T[] tArr, Function2<? super T, ? super S, ? extends S> function2) {.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex >= 0) {.swift
int i = lastIndex - 1;.swift
Object obj = tArr[lastIndex];.swift
while (i >= 0) {.swift
Object invoke = function2.invoke(tArr[i], obj);.swift
i--;.swift
obj = invoke;.swift
}.swift
return obj;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final <S, T extends S> S reduceRightIndexed(T[] tArr, Function3<? super Integer, ? super T, ? super S, ? extends S> function3) {.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex >= 0) {.swift
int i = lastIndex - 1;.swift
Object obj = tArr[lastIndex];.swift
while (i >= 0) {.swift
i--;.swift
obj = function3.invoke(Integer.valueOf(i), tArr[i], obj);.swift
}.swift
return obj;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <S, T extends S> S reduceRightIndexedOrNull(T[] tArr, Function3<? super Integer, ? super T, ? super S, ? extends S> function3) {.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
int i = lastIndex - 1;.swift
Object obj = tArr[lastIndex];.swift
while (i >= 0) {.swift
i--;.swift
obj = function3.invoke(Integer.valueOf(i), tArr[i], obj);.swift
}.swift
return obj;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <S, T extends S> S reduceRightOrNull(T[] tArr, Function2<? super T, ? super S, ? extends S> function2) {.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
int i = lastIndex - 1;.swift
Object obj = tArr[lastIndex];.swift
while (i >= 0) {.swift
Object invoke = function2.invoke(tArr[i], obj);.swift
i--;.swift
obj = invoke;.swift
}.swift
return obj;.swift
}.swift
public static final <T> T[] requireNoNulls(T[] tArr) {.swift
int length = tArr.length;.swift
int i = 0;.swift
while (i < length) {.swift
if (tArr[i] = null) {.swift
i++;.swift
} else {.swift
throw new IllegalArgumentException("null element found in " + tArr + '.');.swift
}.swift
}.swift
return tArr;.swift
}.swift
public static <T> void reverse(T[] tArr) {.swift
int length = (tArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(tArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
T t = tArr[i];.swift
tArr[i] = tArr[lastIndex];.swift
tArr[lastIndex] = t;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
public static final <T> List<T> reversed(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<T> mutableList = toMutableList(tArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
public static final <T> T[] reversedArray(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return tArr;.swift
}.swift
T[] arrayOfNulls = ArraysKt__ArraysJVMKt.arrayOfNulls(tArr, tArr.length);.swift
int lastIndex = getLastIndex(tArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
arrayOfNulls[lastIndex - i] = tArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return arrayOfNulls;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super T, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> java.util.List<R> runningFold(T[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super T, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
return r4.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0023.swift
r3 = r4[r2].swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0023:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super T, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> java.util.List<R> runningFoldIndexed(T[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super T, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super S, ? super T, ? extends S>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <S, T extends S> java.util.List<S> runningReduce(T[] r5, kotlin.jvm.functions.Function2<? super S, ? super T, ? extends S> r6) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsKt.emptyList().swift
return r5.swift
L_0x0008:.swift
r0 = 0.swift
r0 = r5[r0].swift
java.util.ArrayList r1 = new java.util.ArrayList.swift
int r2 = r5.length.swift
r1.<init>(r2).swift
r1.add(r0).swift
int r2 = r5.length.swift
r3 = 1.swift
L_0x0016:.swift
if (r3 >= r2) goto L_0x0024.swift
r4 = r5[r3].swift
java.lang.Object r0 = r6.invoke(r0, r4).swift
r1.add(r0).swift
int r3 = r3 + 1.swift
goto L_0x0016.swift
L_0x0024:.swift
return r1.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningReduce(java.lang.Object[], kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super S, ? super T, ? extends S>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <S, T extends S> java.util.List<S> runningReduceIndexed(T[] r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super S, ? super T, ? extends S> r7) {.swift
/*.swift
int r0 = r6.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r6 = kotlin.collections.CollectionsKt__CollectionsKt.emptyList().swift
return r6.swift
L_0x0008:.swift
r0 = 0.swift
r0 = r6[r0].swift
java.util.ArrayList r1 = new java.util.ArrayList.swift
int r2 = r6.length.swift
r1.<init>(r2).swift
r1.add(r0).swift
int r2 = r6.length.swift
r3 = 1.swift
L_0x0016:.swift
if (r3 >= r2) goto L_0x0028.swift
java.lang.Integer r4 = java.lang.Integer.valueOf(r3).swift
r5 = r6[r3].swift
java.lang.Object r0 = r7.invoke(r4, r0, r5).swift
r1.add(r0).swift
int r3 = r3 + 1.swift
goto L_0x0016.swift
L_0x0028:.swift
return r1.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningReduceIndexed(java.lang.Object[], kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Byte, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(byte[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Byte, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
byte r3 = r4[r2].swift
java.lang.Byte r3 = java.lang.Byte.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r4 = r0.swift
L_0x0028:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(byte[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Byte, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(byte[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Byte, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
byte r4 = r5[r2].swift
java.lang.Byte r4 = java.lang.Byte.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r5 = r0.swift
L_0x002c:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(byte[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T> void shuffle(T[] tArr) {.swift
shuffle(tArr, (Random) Random.Default);.swift
}.swift
public static final <T> T single(T[] tArr) {.swift
int length = tArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return tArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static <T> T singleOrNull(T[] tArr) {.swift
if (tArr.length == 1) {.swift
return tArr[0];.swift
}.swift
return null;.swift
}.swift
public static final <T> List<T> slice(T[] tArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList((T[]) ArraysKt___ArraysJvmKt.copyOfRange(tArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
public static final <T> T[] sliceArray(T[] tArr, Collection<Integer> collection) {.swift
T[] arrayOfNulls = ArraysKt__ArraysJVMKt.arrayOfNulls(tArr, collection.size());.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
arrayOfNulls[i] = tArr[intValue.intValue()];.swift
i++;.swift
}.swift
return arrayOfNulls;.swift
}.swift
public static final <T, R extends Comparable<? super R>> void sortBy(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sortWith(tArr, new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
}.swift
public static final <T, R extends Comparable<? super R>> void sortByDescending(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
if (tArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sortWith(tArr, new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
}.swift
public static final <T extends Comparable<? super T>> void sortDescending(T[] tArr) {.swift
ArraysKt___ArraysJvmKt.sortWith(tArr, ComparisonsKt.reverseOrder());.swift
}.swift
public static final <T extends Comparable<? super T>> List<T> sorted(T[] tArr) {.swift
return ArraysKt___ArraysJvmKt.asList((T[]) sortedArray(tArr));.swift
}.swift
public static final <T extends Comparable<? super T>> T[] sortedArray(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return tArr;.swift
}.swift
T[] tArr2 = (Comparable[]) Arrays.copyOf(tArr, tArr.length);.swift
ArraysKt___ArraysJvmKt.sort(tArr2);.swift
return tArr2;.swift
}.swift
public static final <T extends Comparable<? super T>> T[] sortedArrayDescending(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return tArr;.swift
}.swift
T[] tArr2 = (Comparable[]) Arrays.copyOf(tArr, tArr.length);.swift
ArraysKt___ArraysJvmKt.sortWith(tArr2, ComparisonsKt.reverseOrder());.swift
return tArr2;.swift
}.swift
public static final <T> T[] sortedArrayWith(T[] tArr, Comparator<? super T> comparator) {.swift
if (tArr.length == 0) {.swift
return tArr;.swift
}.swift
T[] copyOf = Arrays.copyOf(tArr, tArr.length);.swift
ArraysKt___ArraysJvmKt.sortWith(copyOf, comparator);.swift
return copyOf;.swift
}.swift
public static final <T, R extends Comparable<? super R>> List<T> sortedBy(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
return sortedWith(tArr, new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <T, R extends Comparable<? super R>> List<T> sortedByDescending(T[] tArr, Function1<? super T, ? extends R> function1) {.swift
return sortedWith(tArr, new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final <T extends Comparable<? super T>> List<T> sortedDescending(T[] tArr) {.swift
return sortedWith(tArr, ComparisonsKt.reverseOrder());.swift
}.swift
public static final <T> List<T> sortedWith(T[] tArr, Comparator<? super T> comparator) {.swift
return ArraysKt___ArraysJvmKt.asList((T[]) sortedArrayWith(tArr, comparator));.swift
}.swift
public static final <T> Set<T> subtract(T[] tArr, Iterable<? extends T> iterable) {.swift
Set<T> mutableSet = toMutableSet(tArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final int sum(byte[] bArr) {.swift
int i = 0;.swift
for (byte b : bArr) {.swift
i += b;.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final <T> int sumBy(T[] tArr, Function1<? super T, Integer> function1) {.swift
int i = 0;.swift
for (T invoke : tArr) {.swift
i += function1.invoke(invoke).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final <T> double sumByDouble(T[] tArr, Function1<? super T, Double> function1) {.swift
double d = 0.0d;.swift
for (T invoke : tArr) {.swift
d += function1.invoke(invoke).doubleValue();.swift
}.swift
return d;.swift
}.swift
@JvmName(name = "sumOfByte").swift
public static final int sumOfByte(Byte[] bArr) {.swift
int i = 0;.swift
for (Byte byteValue : bArr) {.swift
i += byteValue.byteValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final <T> double sumOfDouble(T[] tArr, Function1<? super T, Double> function1) {.swift
double d = 0.0d;.swift
for (T invoke : tArr) {.swift
d += function1.invoke(invoke).doubleValue();.swift
}.swift
return d;.swift
}.swift
@JvmName(name = "sumOfFloat").swift
public static final float sumOfFloat(Float[] fArr) {.swift
float f = c44.DEFAULT_ASPECT_RATIO;.swift
for (Float floatValue : fArr) {.swift
f += floatValue.floatValue();.swift
}.swift
return f;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final <T> int sumOfInt(T[] tArr, Function1<? super T, Integer> function1) {.swift
int i = 0;.swift
for (T invoke : tArr) {.swift
i += function1.invoke(invoke).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final <T> long sumOfLong(T[] tArr, Function1<? super T, Long> function1) {.swift
long j = 0;.swift
for (T invoke : tArr) {.swift
j += function1.invoke(invoke).longValue();.swift
}.swift
return j;.swift
}.swift
@JvmName(name = "sumOfShort").swift
public static final int sumOfShort(Short[] shArr) {.swift
int i = 0;.swift
for (Short shortValue : shArr) {.swift
i += shortValue.shortValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final <T> int sumOfUInt(T[] tArr, Function1<? super T, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (T invoke : tArr) {.swift
r1 = tr1.g(function1.invoke(invoke), r1);.swift
}.swift
return r1;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final <T> long sumOfULong(T[] tArr, Function1<? super T, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (T invoke : tArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(invoke).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static <T> List<T> take(T[] tArr, int i) {.swift
if (i < 0) {.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
} else if (i == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
} else {.swift
if (i >= tArr.length) {.swift
return toList(tArr);.swift
}.swift
if (i == 1) {.swift
return CollectionsKt__CollectionsJVMKt.listOf(tArr[0]);.swift
}.swift
ArrayList arrayList = new ArrayList(i);.swift
int i2 = 0;.swift
for (T add : tArr) {.swift
arrayList.add(add);.swift
i2++;.swift
if (i2 == i) {.swift
break;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
}.swift
public static final <T> List<T> takeLast(T[] tArr, int i) {.swift
if (i < 0) {.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
} else if (i == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
} else {.swift
int length = tArr.length;.swift
if (i >= length) {.swift
return toList(tArr);.swift
}.swift
if (i == 1) {.swift
return CollectionsKt__CollectionsJVMKt.listOf(tArr[length - 1]);.swift
}.swift
ArrayList arrayList = new ArrayList(i);.swift
for (int i2 = length - i; i2 < length; i2++) {.swift
arrayList.add(tArr[i2]);.swift
}.swift
return arrayList;.swift
}.swift
}.swift
public static final <T> List<T> takeLastWhile(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(tArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(tArr[lastIndex]).booleanValue()) {.swift
return drop(tArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(tArr);.swift
}.swift
public static final <T> List<T> takeWhile(T[] tArr, Function1<? super T, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(t);.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean[] toBooleanArray(Boolean[] boolArr) {.swift
int length = boolArr.length;.swift
boolean[] zArr = new boolean[length];.swift
for (int i = 0; i < length; i++) {.swift
zArr[i] = boolArr[i].booleanValue();.swift
}.swift
return zArr;.swift
}.swift
public static final byte[] toByteArray(Byte[] bArr) {.swift
int length = bArr.length;.swift
byte[] bArr2 = new byte[length];.swift
for (int i = 0; i < length; i++) {.swift
bArr2[i] = bArr[i].byteValue();.swift
}.swift
return bArr2;.swift
}.swift
public static final char[] toCharArray(Character[] chArr) {.swift
int length = chArr.length;.swift
char[] cArr = new char[length];.swift
for (int i = 0; i < length; i++) {.swift
cArr[i] = chArr[i].charValue();.swift
}.swift
return cArr;.swift
}.swift
public static final <T, C extends Collection<? super T>> C toCollection(T[] tArr, C c) {.swift
for (T add : tArr) {.swift
c.add(add);.swift
}.swift
return c;.swift
}.swift
public static final double[] toDoubleArray(Double[] dArr) {.swift
int length = dArr.length;.swift
double[] dArr2 = new double[length];.swift
for (int i = 0; i < length; i++) {.swift
dArr2[i] = dArr[i].doubleValue();.swift
}.swift
return dArr2;.swift
}.swift
public static final float[] toFloatArray(Float[] fArr) {.swift
int length = fArr.length;.swift
float[] fArr2 = new float[length];.swift
for (int i = 0; i < length; i++) {.swift
fArr2[i] = fArr[i].floatValue();.swift
}.swift
return fArr2;.swift
}.swift
public static final <T> HashSet<T> toHashSet(T[] tArr) {.swift
return (HashSet) toCollection(tArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(tArr.length)));.swift
}.swift
public static final int[] toIntArray(Integer[] numArr) {.swift
int length = numArr.length;.swift
int[] iArr = new int[length];.swift
for (int i = 0; i < length; i++) {.swift
iArr[i] = numArr[i].intValue();.swift
}.swift
return iArr;.swift
}.swift
public static <T> List<T> toList(T[] tArr) {.swift
int length = tArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(tArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(tArr[0]);.swift
}.swift
public static final long[] toLongArray(Long[] lArr) {.swift
int length = lArr.length;.swift
long[] jArr = new long[length];.swift
for (int i = 0; i < length; i++) {.swift
jArr[i] = lArr[i].longValue();.swift
}.swift
return jArr;.swift
}.swift
public static <T> List<T> toMutableList(T[] tArr) {.swift
return new ArrayList(CollectionsKt__CollectionsKt.asCollection(tArr));.swift
}.swift
public static final <T> Set<T> toMutableSet(T[] tArr) {.swift
return (Set) toCollection(tArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(tArr.length)));.swift
}.swift
public static final <T> Set<T> toSet(T[] tArr) {.swift
int length = tArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(tArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(tArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(tArr[0]);.swift
}.swift
public static final short[] toShortArray(Short[] shArr) {.swift
int length = shArr.length;.swift
short[] sArr = new short[length];.swift
for (int i = 0; i < length; i++) {.swift
sArr[i] = shArr[i].shortValue();.swift
}.swift
return sArr;.swift
}.swift
public static final <T> Set<T> union(T[] tArr, Iterable<? extends T> iterable) {.swift
Set<T> mutableSet = toMutableSet(tArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static <T> Iterable<IndexedValue<T>> withIndex(T[] tArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$1(tArr));.swift
}.swift
public static final <T, R, V> List<V> zip(T[] tArr, R[] rArr, Function2<? super T, ? super R, ? extends V> function2) {.swift
int min = Math.min(tArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(tArr[i], rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean all(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (byte valueOf : bArr) {.swift
if (function1.invoke(Byte.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static boolean any(byte[] bArr) {.swift
return (bArr.length == 0);.swift
}.swift
public static final double average(short[] sArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (short s : sArr) {.swift
d += (double) s;.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@InlineOnly.swift
private static final byte component1(byte[] bArr) {.swift
return bArr[0];.swift
}.swift
@InlineOnly.swift
private static final byte component2(byte[] bArr) {.swift
return bArr[1];.swift
}.swift
@InlineOnly.swift
private static final byte component3(byte[] bArr) {.swift
return bArr[2];.swift
}.swift
@InlineOnly.swift
private static final byte component4(byte[] bArr) {.swift
return bArr[3];.swift
}.swift
@InlineOnly.swift
private static final byte component5(byte[] bArr) {.swift
return bArr[4];.swift
}.swift
public static boolean contains(byte[] bArr, byte b) {.swift
return indexOf(bArr, b) >= 0;.swift
}.swift
@InlineOnly.swift
private static final int count(byte[] bArr) {.swift
return bArr.length;.swift
}.swift
public static final List<Byte> distinct(byte[] bArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(bArr));.swift
}.swift
@InlineOnly.swift
private static final byte elementAtOrElse(byte[] bArr, int i, Function1<? super Integer, Byte> function1) {.swift
return (i < 0 || i >= bArr.length) ? function1.invoke(Integer.valueOf(i)).byteValue() : bArr[i];.swift
}.swift
@InlineOnly.swift
private static final Byte elementAtOrNull(byte[] bArr, int i) {.swift
return getOrNull(bArr, i);.swift
}.swift
public static final <C extends Collection<? super Byte>> C filterNotTo(byte[] bArr, C c, Function1<? super Byte, Boolean> function1) {.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
c.add(Byte.valueOf(b));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Byte>> C filterTo(byte[] bArr, C c, Function1<? super Byte, Boolean> function1) {.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
c.add(Byte.valueOf(b));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Byte find(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
return Byte.valueOf(b);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final Byte firstOrNull(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
return Byte.valueOf(bArr[0]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(byte[] bArr, Function2<? super Integer, ? super Byte, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Byte.valueOf(bArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Byte, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(byte[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Byte, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
byte r2 = r3[r1].swift
java.lang.Byte r2 = java.lang.Byte.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(byte[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Byte, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(byte[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Byte, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
byte r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Byte r3 = java.lang.Byte.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0019:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(byte[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(byte[] bArr, Function1<? super Byte, Unit> function1) {.swift
for (byte valueOf : bArr) {.swift
function1.invoke(Byte.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(byte[] bArr, Function2<? super Integer, ? super Byte, Unit> function2) {.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Byte.valueOf(bArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static IntRange getIndices(byte[] bArr) {.swift
return new IntRange(0, getLastIndex(bArr));.swift
}.swift
public static int getLastIndex(byte[] bArr) {.swift
return bArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final byte getOrElse(byte[] bArr, int i, Function1<? super Integer, Byte> function1) {.swift
return (i < 0 || i >= bArr.length) ? function1.invoke(Integer.valueOf(i)).byteValue() : bArr[i];.swift
}.swift
public static final Byte getOrNull(byte[] bArr, int i) {.swift
if (i < 0 || i >= bArr.length) {.swift
return null;.swift
}.swift
return Byte.valueOf(bArr[i]);.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(byte[] bArr) {.swift
return bArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(byte[] bArr) {.swift
return (bArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(byte[] bArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(bArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Byte, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(byte[] bArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Byte, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(bArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(byte[] bArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(bArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Byte, ? extends CharSequence>) function1);.swift
}.swift
public static final Byte lastOrNull(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
return Byte.valueOf(bArr[bArr.length - 1]);.swift
}.swift
public static final boolean none(byte[] bArr) {.swift
return bArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final byte[] onEach(byte[] bArr, Function1<? super Byte, Unit> function1) {.swift
for (byte valueOf : bArr) {.swift
function1.invoke(Byte.valueOf(valueOf));.swift
}.swift
return bArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final byte[] onEachIndexed(byte[] bArr, Function2<? super Integer, ? super Byte, Unit> function2) {.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Byte.valueOf(bArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return bArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final byte random(byte[] bArr) {.swift
return random(bArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Byte randomOrNull(byte[] bArr) {.swift
return randomOrNull(bArr, (Random) Random.Default);.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Short, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(short[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Short, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
short r3 = r4[r2].swift
java.lang.Short r3 = java.lang.Short.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r4 = r0.swift
L_0x0028:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(short[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Short, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(short[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Short, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
short r4 = r5[r2].swift
java.lang.Short r4 = java.lang.Short.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r5 = r0.swift
L_0x002c:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(short[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(byte[] bArr) {.swift
shuffle(bArr, (Random) Random.Default);.swift
}.swift
public static final Byte singleOrNull(byte[] bArr) {.swift
if (bArr.length == 1) {.swift
return Byte.valueOf(bArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final void sortDescending(byte[] bArr) {.swift
if (bArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(bArr);.swift
reverse(bArr);.swift
}.swift
}.swift
public static final List<Byte> sorted(byte[] bArr) {.swift
Byte[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(bArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final <R extends Comparable<? super R>> List<Byte> sortedBy(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
return sortedWith(bArr, (Comparator<? super Byte>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Byte> sortedByDescending(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
return sortedWith(bArr, (Comparator<? super Byte>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Byte> sortedDescending(byte[] bArr) {.swift
byte[] copyOf = Arrays.copyOf(bArr, bArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Byte> sortedWith(byte[] bArr, Comparator<? super Byte> comparator) {.swift
Byte[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(bArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final int sum(short[] sArr) {.swift
int i = 0;.swift
for (short s : sArr) {.swift
i += s;.swift
}.swift
return i;.swift
}.swift
public static final HashSet<Byte> toHashSet(byte[] bArr) {.swift
return (HashSet) toCollection(bArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(bArr.length)));.swift
}.swift
public static final List<Byte> toMutableList(byte[] bArr) {.swift
ArrayList arrayList = new ArrayList(bArr.length);.swift
for (byte valueOf : bArr) {.swift
arrayList.add(Byte.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final Set<Byte> toMutableSet(byte[] bArr) {.swift
return (Set) toCollection(bArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(bArr.length)));.swift
}.swift
public static final Iterable<IndexedValue<Byte>> withIndex(byte[] bArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$2(bArr));.swift
}.swift
public static final boolean all(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (short valueOf : sArr) {.swift
if (function1.invoke(Short.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static boolean any(short[] sArr) {.swift
return (sArr.length == 0);.swift
}.swift
public static final Iterable<Byte> asIterable(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$2(bArr);.swift
}.swift
public static final Sequence<Byte> asSequence(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$2(bArr);.swift
}.swift
public static final <K, M extends Map<? super K, ? super Byte>> M associateByTo(byte[] bArr, M m, Function1<? super Byte, ? extends K> function1) {.swift
for (byte b : bArr) {.swift
m.put(function1.invoke(Byte.valueOf(b)), Byte.valueOf(b));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(byte[] bArr, M m, Function1<? super Byte, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (byte valueOf : bArr) {.swift
Pair pair = (Pair) function1.invoke(Byte.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Byte, ? super V>> M associateWithTo(byte[] bArr, M m, Function1<? super Byte, ? extends V> function1) {.swift
for (byte b : bArr) {.swift
m.put(Byte.valueOf(b), function1.invoke(Byte.valueOf(b)));.swift
}.swift
return m;.swift
}.swift
public static final double average(int[] iArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (int i2 : iArr) {.swift
d += (double) i2;.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@InlineOnly.swift
private static final short component1(short[] sArr) {.swift
return sArr[0];.swift
}.swift
@InlineOnly.swift
private static final short component2(short[] sArr) {.swift
return sArr[1];.swift
}.swift
@InlineOnly.swift
private static final short component3(short[] sArr) {.swift
return sArr[2];.swift
}.swift
@InlineOnly.swift
private static final short component4(short[] sArr) {.swift
return sArr[3];.swift
}.swift
@InlineOnly.swift
private static final short component5(short[] sArr) {.swift
return sArr[4];.swift
}.swift
public static boolean contains(short[] sArr, short s) {.swift
return indexOf(sArr, s) >= 0;.swift
}.swift
@InlineOnly.swift
private static final int count(short[] sArr) {.swift
return sArr.length;.swift
}.swift
public static final List<Short> distinct(short[] sArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(sArr));.swift
}.swift
@InlineOnly.swift
private static final short elementAtOrElse(short[] sArr, int i, Function1<? super Integer, Short> function1) {.swift
return (i < 0 || i >= sArr.length) ? function1.invoke(Integer.valueOf(i)).shortValue() : sArr[i];.swift
}.swift
@InlineOnly.swift
private static final Short elementAtOrNull(short[] sArr, int i) {.swift
return getOrNull(sArr, i);.swift
}.swift
public static final List<Byte> filter(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Byte>> C filterIndexedTo(byte[] bArr, C c, Function2<? super Integer, ? super Byte, Boolean> function2) {.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
byte b = bArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Byte.valueOf(b)).booleanValue()) {.swift
c.add(Byte.valueOf(b));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Byte> filterNot(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Short>> C filterNotTo(short[] sArr, C c, Function1<? super Short, Boolean> function1) {.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
c.add(Short.valueOf(s));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Short>> C filterTo(short[] sArr, C c, Function1<? super Short, Boolean> function1) {.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
c.add(Short.valueOf(s));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Short find(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
return Short.valueOf(s);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final Short firstOrNull(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
return Short.valueOf(sArr[0]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(short[] sArr, Function2<? super Integer, ? super Short, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Short.valueOf(sArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Short, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(short[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Short, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
short r2 = r3[r1].swift
java.lang.Short r2 = java.lang.Short.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(short[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Short, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(short[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Short, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
short r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Short r3 = java.lang.Short.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0019:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(short[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Byte, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(byte[] r2, R r3, kotlin.jvm.functions.Function2<? super java.lang.Byte, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((byte[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
byte r0 = r2[r0].swift
java.lang.Byte r0 = java.lang.Byte.valueOf(r0).swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(byte[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Byte, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(byte[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Byte, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((byte[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
byte r2 = r3[r0].swift
java.lang.Byte r2 = java.lang.Byte.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(byte[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(short[] sArr, Function1<? super Short, Unit> function1) {.swift
for (short valueOf : sArr) {.swift
function1.invoke(Short.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(short[] sArr, Function2<? super Integer, ? super Short, Unit> function2) {.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Short.valueOf(sArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static IntRange getIndices(short[] sArr) {.swift
return new IntRange(0, getLastIndex(sArr));.swift
}.swift
public static int getLastIndex(short[] sArr) {.swift
return sArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final short getOrElse(short[] sArr, int i, Function1<? super Integer, Short> function1) {.swift
return (i < 0 || i >= sArr.length) ? function1.invoke(Integer.valueOf(i)).shortValue() : sArr[i];.swift
}.swift
public static final Short getOrNull(short[] sArr, int i) {.swift
if (i < 0 || i >= sArr.length) {.swift
return null;.swift
}.swift
return Short.valueOf(sArr[i]);.swift
}.swift
public static final int indexOfFirst(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
int length = bArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Byte.valueOf(bArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
int length = bArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Byte.valueOf(bArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Byte> intersect(byte[] bArr, Iterable<Byte> iterable) {.swift
Set<Byte> mutableSet = toMutableSet(bArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(short[] sArr) {.swift
return sArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(short[] sArr) {.swift
return (sArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(short[] sArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(sArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Short, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(short[] sArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Short, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(sArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(short[] sArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(sArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Short, ? extends CharSequence>) function1);.swift
}.swift
public static final Short lastOrNull(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
return Short.valueOf(sArr[sArr.length - 1]);.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(byte[] bArr, C c, Function2<? super Integer, ? super Byte, ? extends R> function2) {.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Byte.valueOf(bArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(byte[] bArr, C c, Function1<? super Byte, ? extends R> function1) {.swift
for (byte valueOf : bArr) {.swift
c.add(function1.invoke(Byte.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final boolean none(short[] sArr) {.swift
return sArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final short[] onEach(short[] sArr, Function1<? super Short, Unit> function1) {.swift
for (short valueOf : sArr) {.swift
function1.invoke(Short.valueOf(valueOf));.swift
}.swift
return sArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final short[] onEachIndexed(short[] sArr, Function2<? super Integer, ? super Short, Unit> function2) {.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Short.valueOf(sArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return sArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final short random(short[] sArr) {.swift
return random(sArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Short randomOrNull(short[] sArr) {.swift
return randomOrNull(sArr, (Random) Random.Default);.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Integer, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(int[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Integer, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r4[r2].swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r4 = r0.swift
L_0x0028:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(int[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Integer, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(int[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Integer, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Integer r4 = java.lang.Integer.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r5 = r0.swift
L_0x002c:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(int[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(short[] sArr) {.swift
shuffle(sArr, (Random) Random.Default);.swift
}.swift
public static final Short singleOrNull(short[] sArr) {.swift
if (sArr.length == 1) {.swift
return Short.valueOf(sArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final List<Short> sorted(short[] sArr) {.swift
Short[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(sArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final byte[] sortedArray(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return bArr;.swift
}.swift
byte[] copyOf = Arrays.copyOf(bArr, bArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final byte[] sortedArrayDescending(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return bArr;.swift
}.swift
byte[] copyOf = Arrays.copyOf(bArr, bArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final <R extends Comparable<? super R>> List<Short> sortedBy(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
return sortedWith(sArr, (Comparator<? super Short>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Short> sortedByDescending(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
return sortedWith(sArr, (Comparator<? super Short>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Short> sortedDescending(short[] sArr) {.swift
short[] copyOf = Arrays.copyOf(sArr, sArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Short> sortedWith(short[] sArr, Comparator<? super Short> comparator) {.swift
Short[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(sArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final Set<Byte> subtract(byte[] bArr, Iterable<Byte> iterable) {.swift
Set<Byte> mutableSet = toMutableSet(bArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static int sum(int[] iArr) {.swift
int i = 0;.swift
for (int i2 : iArr) {.swift
i += i2;.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(byte[] bArr, Function1<? super Byte, Integer> function1) {.swift
int i = 0;.swift
for (byte valueOf : bArr) {.swift
i += function1.invoke(Byte.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(byte[] bArr, Function1<? super Byte, Double> function1) {.swift
double d = 0.0d;.swift
for (byte valueOf : bArr) {.swift
d += function1.invoke(Byte.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(byte[] bArr, Function1<? super Byte, Double> function1) {.swift
double d = 0.0d;.swift
for (byte valueOf : bArr) {.swift
d += function1.invoke(Byte.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(byte[] bArr, Function1<? super Byte, Integer> function1) {.swift
int i = 0;.swift
for (byte valueOf : bArr) {.swift
i += function1.invoke(Byte.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(byte[] bArr, Function1<? super Byte, Long> function1) {.swift
long j = 0;.swift
for (byte valueOf : bArr) {.swift
j += function1.invoke(Byte.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
public static final <C extends Collection<? super Byte>> C toCollection(byte[] bArr, C c) {.swift
for (byte valueOf : bArr) {.swift
c.add(Byte.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final HashSet<Short> toHashSet(short[] sArr) {.swift
return (HashSet) toCollection(sArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(sArr.length)));.swift
}.swift
public static final Set<Short> toMutableSet(short[] sArr) {.swift
return (Set) toCollection(sArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(sArr.length)));.swift
}.swift
public static final Set<Byte> union(byte[] bArr, Iterable<Byte> iterable) {.swift
Set<Byte> mutableSet = toMutableSet(bArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final Iterable<IndexedValue<Short>> withIndex(short[] sArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$3(sArr));.swift
}.swift
public static final boolean all(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int valueOf : iArr) {.swift
if (function1.invoke(Integer.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static boolean any(int[] iArr) {.swift
return (iArr.length == 0);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Byte, V> associateWith(byte[] bArr, Function1<? super Byte, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(bArr.length), 16));.swift
for (byte b : bArr) {.swift
linkedHashMap.put(Byte.valueOf(b), function1.invoke(Byte.valueOf(b)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final double average(long[] jArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (long j : jArr) {.swift
d += (double) j;.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@InlineOnly.swift
private static final int component1(int[] iArr) {.swift
return iArr[0];.swift
}.swift
@InlineOnly.swift
private static final int component2(int[] iArr) {.swift
return iArr[1];.swift
}.swift
@InlineOnly.swift
private static final int component3(int[] iArr) {.swift
return iArr[2];.swift
}.swift
@InlineOnly.swift
private static final int component4(int[] iArr) {.swift
return iArr[3];.swift
}.swift
@InlineOnly.swift
private static final int component5(int[] iArr) {.swift
return iArr[4];.swift
}.swift
public static boolean contains(int[] iArr, int i) {.swift
return indexOf(iArr, i) >= 0;.swift
}.swift
@InlineOnly.swift
private static final int count(int[] iArr) {.swift
return iArr.length;.swift
}.swift
public static final List<Integer> distinct(int[] iArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(iArr));.swift
}.swift
@InlineOnly.swift
private static final int elementAtOrElse(int[] iArr, int i, Function1<? super Integer, Integer> function1) {.swift
return (i < 0 || i >= iArr.length) ? function1.invoke(Integer.valueOf(i)).intValue() : iArr[i];.swift
}.swift
@InlineOnly.swift
private static final Integer elementAtOrNull(int[] iArr, int i) {.swift
return getOrNull(iArr, i);.swift
}.swift
public static final List<Byte> filterIndexed(byte[] bArr, Function2<? super Integer, ? super Byte, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
byte b = bArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Byte.valueOf(b)).booleanValue()) {.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Integer>> C filterNotTo(int[] iArr, C c, Function1<? super Integer, Boolean> function1) {.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
c.add(Integer.valueOf(i));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Integer>> C filterTo(int[] iArr, C c, Function1<? super Integer, Boolean> function1) {.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
c.add(Integer.valueOf(i));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Integer find(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
return Integer.valueOf(i);.swift
}.swift
}.swift
return null;.swift
}.swift
@InlineOnly.swift
private static final Byte findLast(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
int length = bArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
byte b = bArr[length];.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
return Byte.valueOf(b);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static byte first(byte[] bArr) {.swift
if (bArr.length = 0) {.swift
return bArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Integer firstOrNull(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
return Integer.valueOf(iArr[0]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(int[] iArr, Function2<? super Integer, ? super Integer, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(byte[] bArr, C c, Function2<? super Integer, ? super Byte, ? extends Iterable<? extends R>> function2) {.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Byte.valueOf(bArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(byte[] bArr, C c, Function1<? super Byte, ? extends Iterable<? extends R>> function1) {.swift
for (byte valueOf : bArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Byte.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Integer, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(int[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Integer, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
r2 = r3[r1].swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(int[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Integer, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(int[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Integer, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0019:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(int[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(int[] iArr, Function1<? super Integer, Unit> function1) {.swift
for (int valueOf : iArr) {.swift
function1.invoke(Integer.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(int[] iArr, Function2<? super Integer, ? super Integer, Unit> function2) {.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static IntRange getIndices(int[] iArr) {.swift
return new IntRange(0, getLastIndex(iArr));.swift
}.swift
public static int getLastIndex(int[] iArr) {.swift
return iArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final int getOrElse(int[] iArr, int i, Function1<? super Integer, Integer> function1) {.swift
return (i < 0 || i >= iArr.length) ? function1.invoke(Integer.valueOf(i)).intValue() : iArr[i];.swift
}.swift
public static Integer getOrNull(int[] iArr, int i) {.swift
if (i < 0 || i >= iArr.length) {.swift
return null;.swift
}.swift
return Integer.valueOf(iArr[i]);.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(int[] iArr) {.swift
return iArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(int[] iArr) {.swift
return (iArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(int[] iArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(iArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Integer, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(int[] iArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Integer, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(iArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(int[] iArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(iArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Integer, ? extends CharSequence>) function1);.swift
}.swift
public static byte last(byte[] bArr) {.swift
if (bArr.length = 0) {.swift
return bArr[getLastIndex(bArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Integer lastOrNull(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
return Integer.valueOf(iArr[iArr.length - 1]);.swift
}.swift
public static final <R> List<R> map(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(bArr.length);.swift
for (byte valueOf : bArr) {.swift
arrayList.add(function1.invoke(Byte.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(byte[] bArr, Function2<? super Integer, ? super Byte, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(bArr.length);.swift
int length = bArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Byte.valueOf(bArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean none(int[] iArr) {.swift
return iArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final int[] onEach(int[] iArr, Function1<? super Integer, Unit> function1) {.swift
for (int valueOf : iArr) {.swift
function1.invoke(Integer.valueOf(valueOf));.swift
}.swift
return iArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final int[] onEachIndexed(int[] iArr, Function2<? super Integer, ? super Integer, Unit> function2) {.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return iArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final int random(int[] iArr) {.swift
return random(iArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Integer randomOrNull(int[] iArr) {.swift
return randomOrNull(iArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte reduceRightIndexedOrNull(byte[] bArr, Function3<? super Integer, ? super Byte, ? super Byte, Byte> function3) {.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
byte b = bArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
b = function3.invoke(Integer.valueOf(i), Byte.valueOf(bArr[i]), Byte.valueOf(b)).byteValue();.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte reduceRightOrNull(byte[] bArr, Function2<? super Byte, ? super Byte, Byte> function2) {.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
byte b = bArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
b = function2.invoke(Byte.valueOf(bArr[i]), Byte.valueOf(b)).byteValue();.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
public static final List<Byte> reversed(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Byte> mutableList = toMutableList(bArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Long, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(long[] r5, R r6, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Long, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r5[r2].swift
java.lang.Long r3 = java.lang.Long.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r6, r3).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r5 = r0.swift
L_0x0028:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(long[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r8v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Long, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(long[] r6, R r7, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Long, ? extends R> r8) {.swift
/*.swift
int r0 = r6.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r6 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r7).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r6.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r7).swift
int r1 = r6.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r6[r2].swift
java.lang.Long r4 = java.lang.Long.valueOf(r4).swift
java.lang.Object r7 = r8.invoke(r3, r7, r4).swift
r0.add(r7).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r6 = r0.swift
L_0x002c:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(long[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(int[] iArr) {.swift
shuffle(iArr, (Random) Random.Default);.swift
}.swift
public static final Integer singleOrNull(int[] iArr) {.swift
if (iArr.length == 1) {.swift
return Integer.valueOf(iArr[0]);.swift
}.swift
return null;.swift
}.swift
public static byte[] sliceArray(byte[] bArr, Collection<Integer> collection) {.swift
byte[] bArr2 = new byte[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
bArr2[i] = bArr[intValue.intValue()];.swift
i++;.swift
}.swift
return bArr2;.swift
}.swift
public static final List<Integer> sorted(int[] iArr) {.swift
Integer[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(iArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final <R extends Comparable<? super R>> List<Integer> sortedBy(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
return sortedWith(iArr, (Comparator<? super Integer>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Integer> sortedByDescending(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
return sortedWith(iArr, (Comparator<? super Integer>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Integer> sortedDescending(int[] iArr) {.swift
int[] copyOf = Arrays.copyOf(iArr, iArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Integer> sortedWith(int[] iArr, Comparator<? super Integer> comparator) {.swift
Integer[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(iArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static long sum(long[] jArr) {.swift
long j = 0;.swift
for (long j2 : jArr) {.swift
j += j2;.swift
}.swift
return j;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(byte[] bArr, Function1<? super Byte, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (byte valueOf : bArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Byte.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final HashSet<Integer> toHashSet(int[] iArr) {.swift
return (HashSet) toCollection(iArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(iArr.length)));.swift
}.swift
public static final List<Short> toMutableList(short[] sArr) {.swift
ArrayList arrayList = new ArrayList(sArr.length);.swift
for (short valueOf : sArr) {.swift
arrayList.add(Short.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final Set<Integer> toMutableSet(int[] iArr) {.swift
return (Set) toCollection(iArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(iArr.length)));.swift
}.swift
public static final Iterable<IndexedValue<Integer>> withIndex(int[] iArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$4(iArr));.swift
}.swift
public static final <R, V> List<V> zip(byte[] bArr, R[] rArr, Function2<? super Byte, ? super R, ? extends V> function2) {.swift
int min = Math.min(bArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Byte.valueOf(bArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean all(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (long valueOf : jArr) {.swift
if (function1.invoke(Long.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static boolean any(long[] jArr) {.swift
return (jArr.length == 0);.swift
}.swift
public static final Iterable<Short> asIterable(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$3(sArr);.swift
}.swift
public static final Sequence<Short> asSequence(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$3(sArr);.swift
}.swift
public static final <K, V> Map<K, V> associate(byte[] bArr, Function1<? super Byte, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(bArr.length), 16));.swift
for (byte valueOf : bArr) {.swift
Pair pair = (Pair) function1.invoke(Byte.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Byte> associateBy(byte[] bArr, Function1<? super Byte, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(bArr.length), 16));.swift
for (byte b : bArr) {.swift
linkedHashMap.put(function1.invoke(Byte.valueOf(b)), Byte.valueOf(b));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, M extends Map<? super K, ? super Short>> M associateByTo(short[] sArr, M m, Function1<? super Short, ? extends K> function1) {.swift
for (short s : sArr) {.swift
m.put(function1.invoke(Short.valueOf(s)), Short.valueOf(s));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(short[] sArr, M m, Function1<? super Short, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (short valueOf : sArr) {.swift
Pair pair = (Pair) function1.invoke(Short.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Short, ? super V>> M associateWithTo(short[] sArr, M m, Function1<? super Short, ? extends V> function1) {.swift
for (short s : sArr) {.swift
m.put(Short.valueOf(s), function1.invoke(Short.valueOf(s)));.swift
}.swift
return m;.swift
}.swift
public static final double average(float[] fArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (float f : fArr) {.swift
d += (double) f;.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@InlineOnly.swift
private static final long component1(long[] jArr) {.swift
return jArr[0];.swift
}.swift
@InlineOnly.swift
private static final long component2(long[] jArr) {.swift
return jArr[1];.swift
}.swift
@InlineOnly.swift
private static final long component3(long[] jArr) {.swift
return jArr[2];.swift
}.swift
@InlineOnly.swift
private static final long component4(long[] jArr) {.swift
return jArr[3];.swift
}.swift
@InlineOnly.swift
private static final long component5(long[] jArr) {.swift
return jArr[4];.swift
}.swift
public static boolean contains(long[] jArr, long j) {.swift
return indexOf(jArr, j) >= 0;.swift
}.swift
@InlineOnly.swift
private static final int count(long[] jArr) {.swift
return jArr.length;.swift
}.swift
public static final List<Long> distinct(long[] jArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(jArr));.swift
}.swift
public static final List<Byte> dropLastWhile(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(bArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Byte.valueOf(bArr[lastIndex])).booleanValue()) {.swift
return take(bArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
@InlineOnly.swift
private static final long elementAtOrElse(long[] jArr, int i, Function1<? super Integer, Long> function1) {.swift
return (i < 0 || i >= jArr.length) ? function1.invoke(Integer.valueOf(i)).longValue() : jArr[i];.swift
}.swift
@InlineOnly.swift
private static final Long elementAtOrNull(long[] jArr, int i) {.swift
return getOrNull(jArr, i);.swift
}.swift
public static final List<Short> filter(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Short>> C filterIndexedTo(short[] sArr, C c, Function2<? super Integer, ? super Short, Boolean> function2) {.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
short s = sArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Short.valueOf(s)).booleanValue()) {.swift
c.add(Short.valueOf(s));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Short> filterNot(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Long>> C filterNotTo(long[] jArr, C c, Function1<? super Long, Boolean> function1) {.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
c.add(Long.valueOf(j));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Long>> C filterTo(long[] jArr, C c, Function1<? super Long, Boolean> function1) {.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
c.add(Long.valueOf(j));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Long find(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
return Long.valueOf(j);.swift
}.swift
}.swift
return null;.swift
}.swift
public static Long firstOrNull(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
return Long.valueOf(jArr[0]);.swift
}.swift
public static final <R> List<R> flatMap(byte[] bArr, Function1<? super Byte, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (byte valueOf : bArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Byte.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(long[] jArr, Function2<? super Integer, ? super Long, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Long.valueOf(jArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Long, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(long[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Long, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
r2 = r4[r1].swift
java.lang.Long r2 = java.lang.Long.valueOf(r2).swift
java.lang.Object r5 = r6.invoke(r5, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(long[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r8v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Long, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(long[] r6, R r7, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Long, ? extends R> r8) {.swift
/*.swift
int r0 = r6.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
r3 = r6[r1].swift
int r5 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Long r3 = java.lang.Long.valueOf(r3).swift
java.lang.Object r7 = r8.invoke(r2, r7, r3).swift
int r1 = r1 + 1.swift
r2 = r5.swift
goto L_0x0003.swift
L_0x0019:.swift
return r7.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(long[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Short, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(short[] r2, R r3, kotlin.jvm.functions.Function2<? super java.lang.Short, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((short[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
short r0 = r2[r0].swift
java.lang.Short r0 = java.lang.Short.valueOf(r0).swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(short[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Short, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(short[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Short, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((short[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
short r2 = r3[r0].swift
java.lang.Short r2 = java.lang.Short.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(short[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(long[] jArr, Function1<? super Long, Unit> function1) {.swift
for (long valueOf : jArr) {.swift
function1.invoke(Long.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(long[] jArr, Function2<? super Integer, ? super Long, Unit> function2) {.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Long.valueOf(jArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static IntRange getIndices(long[] jArr) {.swift
return new IntRange(0, getLastIndex(jArr));.swift
}.swift
public static int getLastIndex(long[] jArr) {.swift
return jArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final long getOrElse(long[] jArr, int i, Function1<? super Integer, Long> function1) {.swift
return (i < 0 || i >= jArr.length) ? function1.invoke(Integer.valueOf(i)).longValue() : jArr[i];.swift
}.swift
public static final Long getOrNull(long[] jArr, int i) {.swift
if (i < 0 || i >= jArr.length) {.swift
return null;.swift
}.swift
return Long.valueOf(jArr[i]);.swift
}.swift
public static int indexOf(byte[] bArr, byte b) {.swift
int length = bArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (b == bArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
int length = sArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Short.valueOf(sArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
int length = sArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Short.valueOf(sArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Short> intersect(short[] sArr, Iterable<Short> iterable) {.swift
Set<Short> mutableSet = toMutableSet(sArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(long[] jArr) {.swift
return jArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(long[] jArr) {.swift
return (jArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(long[] jArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(jArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Long, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static String joinToString(long[] jArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Long, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(jArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(long[] jArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(jArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Long, ? extends CharSequence>) function1);.swift
}.swift
public static int lastIndexOf(byte[] bArr, byte b) {.swift
int length = bArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (b == bArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Long lastOrNull(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
return Long.valueOf(jArr[jArr.length - 1]);.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(short[] sArr, C c, Function2<? super Integer, ? super Short, ? extends R> function2) {.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Short.valueOf(sArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(short[] sArr, C c, Function1<? super Short, ? extends R> function1) {.swift
for (short valueOf : sArr) {.swift
c.add(function1.invoke(Short.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final boolean none(long[] jArr) {.swift
return jArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final long[] onEach(long[] jArr, Function1<? super Long, Unit> function1) {.swift
for (long valueOf : jArr) {.swift
function1.invoke(Long.valueOf(valueOf));.swift
}.swift
return jArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final long[] onEachIndexed(long[] jArr, Function2<? super Integer, ? super Long, Unit> function2) {.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Long.valueOf(jArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return jArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final long random(long[] jArr) {.swift
return random(jArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Long randomOrNull(long[] jArr) {.swift
return randomOrNull(jArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte reduceIndexedOrNull(byte[] bArr, Function3<? super Integer, ? super Byte, ? super Byte, Byte> function3) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
b = function3.invoke(Integer.valueOf(i), Byte.valueOf(b), Byte.valueOf(bArr[i])).byteValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte reduceOrNull(byte[] bArr, Function2<? super Byte, ? super Byte, Byte> function2) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
b = function2.invoke(Byte.valueOf(b), Byte.valueOf(bArr[i])).byteValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
public static final byte reduceRight(byte[] bArr, Function2<? super Byte, ? super Byte, Byte> function2) {.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex >= 0) {.swift
byte b = bArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
b = function2.invoke(Byte.valueOf(bArr[i]), Byte.valueOf(b)).byteValue();.swift
}.swift
return b;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final byte reduceRightIndexed(byte[] bArr, Function3<? super Integer, ? super Byte, ? super Byte, Byte> function3) {.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex >= 0) {.swift
byte b = bArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
b = function3.invoke(Integer.valueOf(i), Byte.valueOf(bArr[i]), Byte.valueOf(b)).byteValue();.swift
}.swift
return b;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static byte[] reversedArray(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return bArr;.swift
}.swift
byte[] bArr2 = new byte[bArr.length];.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
bArr2[lastIndex - i] = bArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return bArr2;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Float, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(float[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Float, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r4[r2].swift
java.lang.Float r3 = java.lang.Float.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r4 = r0.swift
L_0x0028:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(float[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Float, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(float[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Float, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Float r4 = java.lang.Float.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r5 = r0.swift
L_0x002c:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(float[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(long[] jArr) {.swift
shuffle(jArr, (Random) Random.Default);.swift
}.swift
public static byte single(byte[] bArr) {.swift
int length = bArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return bArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final Long singleOrNull(long[] jArr) {.swift
if (jArr.length == 1) {.swift
return Long.valueOf(jArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final void sortDescending(short[] sArr) {.swift
if (sArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(sArr);.swift
reverse(sArr);.swift
}.swift
}.swift
public static final List<Long> sorted(long[] jArr) {.swift
Long[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(jArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final short[] sortedArray(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return sArr;.swift
}.swift
short[] copyOf = Arrays.copyOf(sArr, sArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final short[] sortedArrayDescending(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return sArr;.swift
}.swift
short[] copyOf = Arrays.copyOf(sArr, sArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final <R extends Comparable<? super R>> List<Long> sortedBy(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
return sortedWith(jArr, (Comparator<? super Long>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Long> sortedByDescending(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
return sortedWith(jArr, (Comparator<? super Long>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Long> sortedDescending(long[] jArr) {.swift
long[] copyOf = Arrays.copyOf(jArr, jArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Long> sortedWith(long[] jArr, Comparator<? super Long> comparator) {.swift
Long[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(jArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final Set<Short> subtract(short[] sArr, Iterable<Short> iterable) {.swift
Set<Short> mutableSet = toMutableSet(sArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final float sum(float[] fArr) {.swift
float f = c44.DEFAULT_ASPECT_RATIO;.swift
for (float f2 : fArr) {.swift
f += f2;.swift
}.swift
return f;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(short[] sArr, Function1<? super Short, Integer> function1) {.swift
int i = 0;.swift
for (short valueOf : sArr) {.swift
i += function1.invoke(Short.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(short[] sArr, Function1<? super Short, Double> function1) {.swift
double d = 0.0d;.swift
for (short valueOf : sArr) {.swift
d += function1.invoke(Short.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(short[] sArr, Function1<? super Short, Double> function1) {.swift
double d = 0.0d;.swift
for (short valueOf : sArr) {.swift
d += function1.invoke(Short.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(short[] sArr, Function1<? super Short, Integer> function1) {.swift
int i = 0;.swift
for (short valueOf : sArr) {.swift
i += function1.invoke(Short.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(short[] sArr, Function1<? super Short, Long> function1) {.swift
long j = 0;.swift
for (short valueOf : sArr) {.swift
j += function1.invoke(Short.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
public static final List<Byte> takeLastWhile(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(bArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Byte.valueOf(bArr[lastIndex])).booleanValue()) {.swift
return drop(bArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(bArr);.swift
}.swift
public static final List<Byte> takeWhile(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Short>> C toCollection(short[] sArr, C c) {.swift
for (short valueOf : sArr) {.swift
c.add(Short.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final HashSet<Long> toHashSet(long[] jArr) {.swift
return (HashSet) toCollection(jArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(jArr.length)));.swift
}.swift
public static final List<Byte> toList(byte[] bArr) {.swift
int length = bArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(bArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Byte.valueOf(bArr[0]));.swift
}.swift
public static final Set<Long> toMutableSet(long[] jArr) {.swift
return (Set) toCollection(jArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(jArr.length)));.swift
}.swift
public static final Set<Byte> toSet(byte[] bArr) {.swift
int length = bArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(bArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(bArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Byte.valueOf(bArr[0]));.swift
}.swift
public static final Set<Short> union(short[] sArr, Iterable<Short> iterable) {.swift
Set<Short> mutableSet = toMutableSet(sArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final Iterable<IndexedValue<Long>> withIndex(long[] jArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$5(jArr));.swift
}.swift
public static final boolean all(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (float valueOf : fArr) {.swift
if (function1.invoke(Float.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final boolean any(float[] fArr) {.swift
return (fArr.length == 0);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Short, V> associateWith(short[] sArr, Function1<? super Short, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(sArr.length), 16));.swift
for (short s : sArr) {.swift
linkedHashMap.put(Short.valueOf(s), function1.invoke(Short.valueOf(s)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final double average(double[] dArr) {.swift
double d = 0.0d;.swift
int i = 0;.swift
for (double d2 : dArr) {.swift
d += d2;.swift
i++;.swift
}.swift
if (i == 0) {.swift
return Double.NaN;.swift
}.swift
return d / ((double) i);.swift
}.swift
@InlineOnly.swift
private static final float component1(float[] fArr) {.swift
return fArr[0];.swift
}.swift
@InlineOnly.swift
private static final float component2(float[] fArr) {.swift
return fArr[1];.swift
}.swift
@InlineOnly.swift
private static final float component3(float[] fArr) {.swift
return fArr[2];.swift
}.swift
@InlineOnly.swift
private static final float component4(float[] fArr) {.swift
return fArr[3];.swift
}.swift
@InlineOnly.swift
private static final float component5(float[] fArr) {.swift
return fArr[4];.swift
}.swift
public static final boolean contains(boolean[] zArr, boolean z) {.swift
return indexOf(zArr, z) >= 0;.swift
}.swift
@InlineOnly.swift
private static final int count(float[] fArr) {.swift
return fArr.length;.swift
}.swift
public static final List<Float> distinct(float[] fArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(fArr));.swift
}.swift
public static final List<Byte> dropWhile(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (byte b : bArr) {.swift
if (z) {.swift
arrayList.add(Byte.valueOf(b));.swift
} else if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
arrayList.add(Byte.valueOf(b));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final float elementAtOrElse(float[] fArr, int i, Function1<? super Integer, Float> function1) {.swift
return (i < 0 || i >= fArr.length) ? function1.invoke(Integer.valueOf(i)).floatValue() : fArr[i];.swift
}.swift
@InlineOnly.swift
private static final Float elementAtOrNull(float[] fArr, int i) {.swift
return getOrNull(fArr, i);.swift
}.swift
public static final <C extends Collection<? super Float>> C filterNotTo(float[] fArr, C c, Function1<? super Float, Boolean> function1) {.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
c.add(Float.valueOf(f));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Float>> C filterTo(float[] fArr, C c, Function1<? super Float, Boolean> function1) {.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
c.add(Float.valueOf(f));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Float find(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
return Float.valueOf(f);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final Float firstOrNull(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
return Float.valueOf(fArr[0]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(float[] fArr, Function2<? super Integer, ? super Float, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Float.valueOf(fArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Float, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(float[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Float, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
r2 = r3[r1].swift
java.lang.Float r2 = java.lang.Float.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(float[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Float, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(float[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Float, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Float r3 = java.lang.Float.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0019:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(float[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(float[] fArr, Function1<? super Float, Unit> function1) {.swift
for (float valueOf : fArr) {.swift
function1.invoke(Float.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(float[] fArr, Function2<? super Integer, ? super Float, Unit> function2) {.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Float.valueOf(fArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static final IntRange getIndices(float[] fArr) {.swift
return new IntRange(0, getLastIndex(fArr));.swift
}.swift
public static int getLastIndex(float[] fArr) {.swift
return fArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final float getOrElse(float[] fArr, int i, Function1<? super Integer, Float> function1) {.swift
return (i < 0 || i >= fArr.length) ? function1.invoke(Integer.valueOf(i)).floatValue() : fArr[i];.swift
}.swift
public static final Float getOrNull(float[] fArr, int i) {.swift
if (i < 0 || i >= fArr.length) {.swift
return null;.swift
}.swift
return Float.valueOf(fArr[i]);.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(float[] fArr) {.swift
return fArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(float[] fArr) {.swift
return (fArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(float[] fArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(fArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Float, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(float[] fArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Float, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(fArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(float[] fArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(fArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Float, ? extends CharSequence>) function1);.swift
}.swift
public static final Float lastOrNull(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
return Float.valueOf(fArr[fArr.length - 1]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(byte[] bArr, Comparator<? super R> comparator, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Byte.valueOf(bArr[0]));.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Byte.valueOf(bArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte maxWithOrNull(byte[] bArr, Comparator<? super Byte> comparator) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (comparator.compare(Byte.valueOf(b), Byte.valueOf(b2)) < 0) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(byte[] bArr, Comparator<? super R> comparator, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Byte.valueOf(bArr[0]));.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Byte.valueOf(bArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte minWithOrNull(byte[] bArr, Comparator<? super Byte> comparator) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (comparator.compare(Byte.valueOf(b), Byte.valueOf(b2)) > 0) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
public static final boolean none(float[] fArr) {.swift
return fArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final float[] onEach(float[] fArr, Function1<? super Float, Unit> function1) {.swift
for (float valueOf : fArr) {.swift
function1.invoke(Float.valueOf(valueOf));.swift
}.swift
return fArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final float[] onEachIndexed(float[] fArr, Function2<? super Integer, ? super Float, Unit> function2) {.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Float.valueOf(fArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return fArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final float random(float[] fArr) {.swift
return random(fArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Float randomOrNull(float[] fArr) {.swift
return randomOrNull(fArr, (Random) Random.Default);.swift
}.swift
public static final byte reduce(byte[] bArr, Function2<? super Byte, ? super Byte, Byte> function2) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
b = function2.invoke(Byte.valueOf(b), Byte.valueOf(bArr[i])).byteValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final byte reduceIndexed(byte[] bArr, Function3<? super Integer, ? super Byte, ? super Byte, Byte> function3) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
b = function3.invoke(Integer.valueOf(i), Byte.valueOf(b), Byte.valueOf(bArr[i])).byteValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static void reverse(byte[] bArr) {.swift
int length = (bArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(bArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
byte b = bArr[i];.swift
bArr[i] = bArr[lastIndex];.swift
bArr[lastIndex] = b;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Byte, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(byte[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Byte, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
return r4.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
byte r3 = r4[r2].swift
java.lang.Byte r3 = java.lang.Byte.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(byte[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Byte, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(byte[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Byte, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
byte r4 = r5[r2].swift
java.lang.Byte r4 = java.lang.Byte.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(byte[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Double, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(double[] r5, R r6, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Double, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r5[r2].swift
java.lang.Double r3 = java.lang.Double.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r6, r3).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r5 = r0.swift
L_0x0028:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(double[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r8v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Double, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(double[] r6, R r7, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Double, ? extends R> r8) {.swift
/*.swift
int r0 = r6.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r6 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r7).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r6.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r7).swift
int r1 = r6.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r6[r2].swift
java.lang.Double r4 = java.lang.Double.valueOf(r4).swift
java.lang.Object r7 = r8.invoke(r3, r7, r4).swift
r0.add(r7).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r6 = r0.swift
L_0x002c:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(double[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(float[] fArr) {.swift
shuffle(fArr, (Random) Random.Default);.swift
}.swift
public static final Float singleOrNull(float[] fArr) {.swift
if (fArr.length == 1) {.swift
return Float.valueOf(fArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final List<Float> sorted(float[] fArr) {.swift
Float[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(fArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final <R extends Comparable<? super R>> List<Float> sortedBy(float[] fArr, Function1<? super Float, ? extends R> function1) {.swift
return sortedWith(fArr, (Comparator<? super Float>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Float> sortedByDescending(float[] fArr, Function1<? super Float, ? extends R> function1) {.swift
return sortedWith(fArr, (Comparator<? super Float>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Float> sortedDescending(float[] fArr) {.swift
float[] copyOf = Arrays.copyOf(fArr, fArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Float> sortedWith(float[] fArr, Comparator<? super Float> comparator) {.swift
Float[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(fArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final double sum(double[] dArr) {.swift
double d = 0.0d;.swift
for (double d2 : dArr) {.swift
d += d2;.swift
}.swift
return d;.swift
}.swift
public static final HashSet<Float> toHashSet(float[] fArr) {.swift
return (HashSet) toCollection(fArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(fArr.length)));.swift
}.swift
public static final List<Integer> toMutableList(int[] iArr) {.swift
ArrayList arrayList = new ArrayList(iArr.length);.swift
for (int valueOf : iArr) {.swift
arrayList.add(Integer.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final Set<Float> toMutableSet(float[] fArr) {.swift
return (Set) toCollection(fArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(fArr.length)));.swift
}.swift
public static final Iterable<IndexedValue<Float>> withIndex(float[] fArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$6(fArr));.swift
}.swift
public static final boolean all(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (double valueOf : dArr) {.swift
if (function1.invoke(Double.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final boolean any(double[] dArr) {.swift
return (dArr.length == 0);.swift
}.swift
public static final Iterable<Integer> asIterable(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$4(iArr);.swift
}.swift
public static final Sequence<Integer> asSequence(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$4(iArr);.swift
}.swift
public static final <K, M extends Map<? super K, ? super Integer>> M associateByTo(int[] iArr, M m, Function1<? super Integer, ? extends K> function1) {.swift
for (int i : iArr) {.swift
m.put(function1.invoke(Integer.valueOf(i)), Integer.valueOf(i));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(int[] iArr, M m, Function1<? super Integer, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (int valueOf : iArr) {.swift
Pair pair = (Pair) function1.invoke(Integer.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Integer, ? super V>> M associateWithTo(int[] iArr, M m, Function1<? super Integer, ? extends V> function1) {.swift
for (int i : iArr) {.swift
m.put(Integer.valueOf(i), function1.invoke(Integer.valueOf(i)));.swift
}.swift
return m;.swift
}.swift
@InlineOnly.swift
private static final double component1(double[] dArr) {.swift
return dArr[0];.swift
}.swift
@InlineOnly.swift
private static final double component2(double[] dArr) {.swift
return dArr[1];.swift
}.swift
@InlineOnly.swift
private static final double component3(double[] dArr) {.swift
return dArr[2];.swift
}.swift
@InlineOnly.swift
private static final double component4(double[] dArr) {.swift
return dArr[3];.swift
}.swift
@InlineOnly.swift
private static final double component5(double[] dArr) {.swift
return dArr[4];.swift
}.swift
public static boolean contains(char[] cArr, char c) {.swift
return indexOf(cArr, c) >= 0;.swift
}.swift
@InlineOnly.swift
private static final int count(double[] dArr) {.swift
return dArr.length;.swift
}.swift
public static final List<Double> distinct(double[] dArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(dArr));.swift
}.swift
public static final <K> List<Byte> distinctBy(byte[] bArr, Function1<? super Byte, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (byte b : bArr) {.swift
if (hashSet.add(function1.invoke(Byte.valueOf(b)))) {.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final double elementAtOrElse(double[] dArr, int i, Function1<? super Integer, Double> function1) {.swift
return (i < 0 || i >= dArr.length) ? function1.invoke(Integer.valueOf(i)).doubleValue() : dArr[i];.swift
}.swift
@InlineOnly.swift
private static final Double elementAtOrNull(double[] dArr, int i) {.swift
return getOrNull(dArr, i);.swift
}.swift
public static final List<Integer> filter(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
arrayList.add(Integer.valueOf(i));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Short> filterIndexed(short[] sArr, Function2<? super Integer, ? super Short, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
short s = sArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Short.valueOf(s)).booleanValue()) {.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Integer>> C filterIndexedTo(int[] iArr, C c, Function2<? super Integer, ? super Integer, Boolean> function2) {.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
int i3 = iArr[i];.swift
int i4 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Integer.valueOf(i3)).booleanValue()) {.swift
c.add(Integer.valueOf(i3));.swift
}.swift
i++;.swift
i2 = i4;.swift
}.swift
return c;.swift
}.swift
public static final List<Integer> filterNot(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
arrayList.add(Integer.valueOf(i));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Double>> C filterNotTo(double[] dArr, C c, Function1<? super Double, Boolean> function1) {.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
c.add(Double.valueOf(d));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Double>> C filterTo(double[] dArr, C c, Function1<? super Double, Boolean> function1) {.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
c.add(Double.valueOf(d));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Double find(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
return Double.valueOf(d);.swift
}.swift
}.swift
return null;.swift
}.swift
@InlineOnly.swift
private static final Short findLast(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
int length = sArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
short s = sArr[length];.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
return Short.valueOf(s);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static short first(short[] sArr) {.swift
if (sArr.length = 0) {.swift
return sArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Double firstOrNull(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
return Double.valueOf(dArr[0]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(double[] dArr, Function2<? super Integer, ? super Double, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Double.valueOf(dArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(short[] sArr, C c, Function2<? super Integer, ? super Short, ? extends Iterable<? extends R>> function2) {.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Short.valueOf(sArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(short[] sArr, C c, Function1<? super Short, ? extends Iterable<? extends R>> function1) {.swift
for (short valueOf : sArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Short.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Double, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(double[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Double, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
r2 = r4[r1].swift
java.lang.Double r2 = java.lang.Double.valueOf(r2).swift
java.lang.Object r5 = r6.invoke(r5, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(double[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r8v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Double, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(double[] r6, R r7, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Double, ? extends R> r8) {.swift
/*.swift
int r0 = r6.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
r3 = r6[r1].swift
int r5 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Double r3 = java.lang.Double.valueOf(r3).swift
java.lang.Object r7 = r8.invoke(r2, r7, r3).swift
int r1 = r1 + 1.swift
r2 = r5.swift
goto L_0x0003.swift
L_0x0019:.swift
return r7.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(double[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Integer, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(int[] r2, R r3, kotlin.jvm.functions.Function2<? super java.lang.Integer, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((int[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
r0 = r2[r0].swift
java.lang.Integer r0 = java.lang.Integer.valueOf(r0).swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(int[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Integer, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(int[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Integer, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((int[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
r2 = r3[r0].swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(int[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(double[] dArr, Function1<? super Double, Unit> function1) {.swift
for (double valueOf : dArr) {.swift
function1.invoke(Double.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(double[] dArr, Function2<? super Integer, ? super Double, Unit> function2) {.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Double.valueOf(dArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static final IntRange getIndices(double[] dArr) {.swift
return new IntRange(0, getLastIndex(dArr));.swift
}.swift
public static final int getLastIndex(double[] dArr) {.swift
return dArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final double getOrElse(double[] dArr, int i, Function1<? super Integer, Double> function1) {.swift
return (i < 0 || i >= dArr.length) ? function1.invoke(Integer.valueOf(i)).doubleValue() : dArr[i];.swift
}.swift
public static final Double getOrNull(double[] dArr, int i) {.swift
if (i < 0 || i >= dArr.length) {.swift
return null;.swift
}.swift
return Double.valueOf(dArr[i]);.swift
}.swift
public static int indexOf(short[] sArr, short s) {.swift
int length = sArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (s == sArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
int length = iArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Integer.valueOf(iArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
int length = iArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Integer.valueOf(iArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Integer> intersect(int[] iArr, Iterable<Integer> iterable) {.swift
Set<Integer> mutableSet = toMutableSet(iArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(double[] dArr) {.swift
return dArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(double[] dArr) {.swift
return (dArr.length == 0);.swift
}.swift
public static final <A extends Appendable> A joinTo(byte[] bArr, A a, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Byte, ? extends CharSequence> function1) {.swift
a.append(charSequence2);.swift
int i2 = 0;.swift
for (byte b : bArr) {.swift
i2++;.swift
if (i2 > 1) {.swift
a.append(charSequence);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
break;.swift
}.swift
if (function1 = null) {.swift
a.append((CharSequence) function1.invoke(Byte.valueOf(b)));.swift
} else {.swift
a.append(String.valueOf(b));.swift
}.swift
}.swift
if (i >= 0 && i2 > i) {.swift
a.append(charSequence4);.swift
}.swift
a.append(charSequence3);.swift
return a;.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(double[] dArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(dArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Double, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(double[] dArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Double, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(dArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(double[] dArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(dArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Double, ? extends CharSequence>) function1);.swift
}.swift
public static short last(short[] sArr) {.swift
if (sArr.length = 0) {.swift
return sArr[getLastIndex(sArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static int lastIndexOf(short[] sArr, short s) {.swift
int length = sArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (s == sArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Double lastOrNull(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
return Double.valueOf(dArr[dArr.length - 1]);.swift
}.swift
public static final <R> List<R> map(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(sArr.length);.swift
for (short valueOf : sArr) {.swift
arrayList.add(function1.invoke(Short.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(short[] sArr, Function2<? super Integer, ? super Short, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(sArr.length);.swift
int length = sArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Short.valueOf(sArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(int[] iArr, C c, Function2<? super Integer, ? super Integer, ? extends R> function2) {.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(int[] iArr, C c, Function1<? super Integer, ? extends R> function1) {.swift
for (int valueOf : iArr) {.swift
c.add(function1.invoke(Integer.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double maxOf(byte[] bArr, Function1<? super Byte, Double> function1) {.swift
if (bArr.length = 0) {.swift
double doubleValue = function1.invoke(Byte.valueOf(bArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Byte.valueOf(bArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final Double m396maxOfOrNull(byte[] bArr, Function1<? super Byte, Double> function1) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Byte.valueOf(bArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Byte.valueOf(bArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWith(byte[] bArr, Comparator<? super R> comparator, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length = 0) {.swift
R invoke = function1.invoke(Byte.valueOf(bArr[0]));.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Byte.valueOf(bArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float maxOrNull(Float[] fArr) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
float floatValue = fArr[0].floatValue();.swift
int lastIndex = getLastIndex((T[]) fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
floatValue = Math.max(floatValue, fArr[i].floatValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Float.valueOf(floatValue);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final float maxOrThrow(Float[] fArr) {.swift
if (fArr.length = 0) {.swift
float floatValue = fArr[0].floatValue();.swift
int lastIndex = getLastIndex((T[]) fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
floatValue = Math.max(floatValue, fArr[i].floatValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return floatValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final byte maxWithOrThrow(byte[] bArr, Comparator<? super Byte> comparator) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (comparator.compare(Byte.valueOf(b), Byte.valueOf(b2)) < 0) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double minOf(byte[] bArr, Function1<? super Byte, Double> function1) {.swift
if (bArr.length = 0) {.swift
double doubleValue = function1.invoke(Byte.valueOf(bArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Byte.valueOf(bArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final Double m432minOfOrNull(byte[] bArr, Function1<? super Byte, Double> function1) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Byte.valueOf(bArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Byte.valueOf(bArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWith(byte[] bArr, Comparator<? super R> comparator, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length = 0) {.swift
R invoke = function1.invoke(Byte.valueOf(bArr[0]));.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Byte.valueOf(bArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float minOrNull(Float[] fArr) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
float floatValue = fArr[0].floatValue();.swift
int lastIndex = getLastIndex((T[]) fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
floatValue = Math.min(floatValue, fArr[i].floatValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Float.valueOf(floatValue);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final float minOrThrow(Float[] fArr) {.swift
if (fArr.length = 0) {.swift
float floatValue = fArr[0].floatValue();.swift
int lastIndex = getLastIndex((T[]) fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
floatValue = Math.min(floatValue, fArr[i].floatValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return floatValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final byte minWithOrThrow(byte[] bArr, Comparator<? super Byte> comparator) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (comparator.compare(Byte.valueOf(b), Byte.valueOf(b2)) > 0) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
public static final boolean none(double[] dArr) {.swift
return dArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double[] onEach(double[] dArr, Function1<? super Double, Unit> function1) {.swift
for (double valueOf : dArr) {.swift
function1.invoke(Double.valueOf(valueOf));.swift
}.swift
return dArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double[] onEachIndexed(double[] dArr, Function2<? super Integer, ? super Double, Unit> function2) {.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Double.valueOf(dArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return dArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final double random(double[] dArr) {.swift
return random(dArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Double randomOrNull(double[] dArr) {.swift
return randomOrNull(dArr, (Random) Random.Default);.swift
}.swift
public static final List<Short> reversed(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Short> mutableList = toMutableList(sArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Byte> runningReduce(byte[] bArr, Function2<? super Byte, ? super Byte, Byte> function2) {.swift
if (bArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
byte b = bArr[0];.swift
ArrayList arrayList = new ArrayList(bArr.length);.swift
arrayList.add(Byte.valueOf(b));.swift
int length = bArr.length;.swift
for (int i = 1; i < length; i++) {.swift
b = function2.invoke(Byte.valueOf(b), Byte.valueOf(bArr[i])).byteValue();.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Byte> runningReduceIndexed(byte[] bArr, Function3<? super Integer, ? super Byte, ? super Byte, Byte> function3) {.swift
if (bArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
byte b = bArr[0];.swift
ArrayList arrayList = new ArrayList(bArr.length);.swift
arrayList.add(Byte.valueOf(b));.swift
int length = bArr.length;.swift
for (int i = 1; i < length; i++) {.swift
b = function3.invoke(Integer.valueOf(i), Byte.valueOf(b), Byte.valueOf(bArr[i])).byteValue();.swift
arrayList.add(Byte.valueOf(b));.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Boolean, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(boolean[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Boolean, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
boolean r3 = r4[r2].swift
java.lang.Boolean r3 = java.lang.Boolean.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r4 = r0.swift
L_0x0028:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(boolean[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Boolean, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(boolean[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Boolean, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
boolean r4 = r5[r2].swift
java.lang.Boolean r4 = java.lang.Boolean.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r5 = r0.swift
L_0x002c:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(boolean[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(double[] dArr) {.swift
shuffle(dArr, (Random) Random.Default);.swift
}.swift
public static final Double singleOrNull(double[] dArr) {.swift
if (dArr.length == 1) {.swift
return Double.valueOf(dArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final List<Byte> slice(byte[] bArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList(ArraysKt___ArraysJvmKt.copyOfRange(bArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
public static short[] sliceArray(short[] sArr, Collection<Integer> collection) {.swift
short[] sArr2 = new short[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
sArr2[i] = sArr[intValue.intValue()];.swift
i++;.swift
}.swift
return sArr2;.swift
}.swift
public static final List<Double> sorted(double[] dArr) {.swift
Double[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(dArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final int[] sortedArray(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return iArr;.swift
}.swift
int[] copyOf = Arrays.copyOf(iArr, iArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final int[] sortedArrayDescending(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return iArr;.swift
}.swift
int[] copyOf = Arrays.copyOf(iArr, iArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final <R extends Comparable<? super R>> List<Double> sortedBy(double[] dArr, Function1<? super Double, ? extends R> function1) {.swift
return sortedWith(dArr, (Comparator<? super Double>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Double> sortedByDescending(double[] dArr, Function1<? super Double, ? extends R> function1) {.swift
return sortedWith(dArr, (Comparator<? super Double>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Double> sortedDescending(double[] dArr) {.swift
double[] copyOf = Arrays.copyOf(dArr, dArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Double> sortedWith(double[] dArr, Comparator<? super Double> comparator) {.swift
Double[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(dArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final Set<Integer> subtract(int[] iArr, Iterable<Integer> iterable) {.swift
Set<Integer> mutableSet = toMutableSet(iArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(int[] iArr, Function1<? super Integer, Integer> function1) {.swift
int i = 0;.swift
for (int valueOf : iArr) {.swift
i += function1.invoke(Integer.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(int[] iArr, Function1<? super Integer, Double> function1) {.swift
double d = 0.0d;.swift
for (int valueOf : iArr) {.swift
d += function1.invoke(Integer.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(int[] iArr, Function1<? super Integer, Double> function1) {.swift
double d = 0.0d;.swift
for (int valueOf : iArr) {.swift
d += function1.invoke(Integer.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(int[] iArr, Function1<? super Integer, Integer> function1) {.swift
int i = 0;.swift
for (int valueOf : iArr) {.swift
i += function1.invoke(Integer.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(int[] iArr, Function1<? super Integer, Long> function1) {.swift
long j = 0;.swift
for (int valueOf : iArr) {.swift
j += function1.invoke(Integer.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final int sumOfUInt(byte[] bArr, Function1<? super Byte, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (byte valueOf : bArr) {.swift
r1 = tr1.g(function1.invoke(Byte.valueOf(valueOf)), r1);.swift
}.swift
return r1;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(short[] sArr, Function1<? super Short, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (short valueOf : sArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Short.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final <C extends Collection<? super Integer>> C toCollection(int[] iArr, C c) {.swift
for (int valueOf : iArr) {.swift
c.add(Integer.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final HashSet<Double> toHashSet(double[] dArr) {.swift
return (HashSet) toCollection(dArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(dArr.length)));.swift
}.swift
public static final Set<Double> toMutableSet(double[] dArr) {.swift
return (Set) toCollection(dArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(dArr.length)));.swift
}.swift
public static final Set<Integer> union(int[] iArr, Iterable<Integer> iterable) {.swift
Set<Integer> mutableSet = toMutableSet(iArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final Iterable<IndexedValue<Double>> withIndex(double[] dArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$7(dArr));.swift
}.swift
public static final <R, V> List<V> zip(short[] sArr, R[] rArr, Function2<? super Short, ? super R, ? extends V> function2) {.swift
int min = Math.min(sArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Short.valueOf(sArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean all(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean valueOf : zArr) {.swift
if (function1.invoke(Boolean.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final boolean any(boolean[] zArr) {.swift
return (zArr.length == 0);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Integer, V> associateWith(int[] iArr, Function1<? super Integer, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(iArr.length), 16));.swift
for (int i : iArr) {.swift
linkedHashMap.put(Integer.valueOf(i), function1.invoke(Integer.valueOf(i)));.swift
}.swift
return linkedHashMap;.swift
}.swift
@InlineOnly.swift
private static final boolean component1(boolean[] zArr) {.swift
return zArr[0];.swift
}.swift
@InlineOnly.swift
private static final boolean component2(boolean[] zArr) {.swift
return zArr[1];.swift
}.swift
@InlineOnly.swift
private static final boolean component3(boolean[] zArr) {.swift
return zArr[2];.swift
}.swift
@InlineOnly.swift
private static final boolean component4(boolean[] zArr) {.swift
return zArr[3];.swift
}.swift
@InlineOnly.swift
private static final boolean component5(boolean[] zArr) {.swift
return zArr[4];.swift
}.swift
@Deprecated(message = "The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.", replaceWith = @ReplaceWith(expression = "any { it == element }", imports = {})).swift
@DeprecatedSinceKotlin(errorSince = "1.6", hiddenSince = "1.7", warningSince = "1.4").swift
public static final /* synthetic */ boolean contains(float[] fArr, float f) {.swift
for (float f2 : fArr) {.swift
if (f2 == f) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@InlineOnly.swift
private static final int count(boolean[] zArr) {.swift
return zArr.length;.swift
}.swift
public static final List<Boolean> distinct(boolean[] zArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(zArr));.swift
}.swift
@InlineOnly.swift
private static final boolean elementAtOrElse(boolean[] zArr, int i, Function1<? super Integer, Boolean> function1) {.swift
return (i < 0 || i >= zArr.length) ? function1.invoke(Integer.valueOf(i)).booleanValue() : zArr[i];.swift
}.swift
@InlineOnly.swift
private static final Boolean elementAtOrNull(boolean[] zArr, int i) {.swift
return getOrNull(zArr, i);.swift
}.swift
public static final <C extends Collection<? super Boolean>> C filterNotTo(boolean[] zArr, C c, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
c.add(Boolean.valueOf(z));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Boolean>> C filterTo(boolean[] zArr, C c, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
c.add(Boolean.valueOf(z));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Boolean find(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
return Boolean.valueOf(z);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final Boolean firstOrNull(boolean[] zArr) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
return Boolean.valueOf(zArr[0]);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(boolean[] zArr, Function2<? super Integer, ? super Boolean, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Boolean.valueOf(zArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Boolean, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(boolean[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Boolean, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
boolean r2 = r3[r1].swift
java.lang.Boolean r2 = java.lang.Boolean.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(boolean[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Boolean, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(boolean[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Boolean, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
boolean r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Boolean r3 = java.lang.Boolean.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0019:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(boolean[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(boolean[] zArr, Function1<? super Boolean, Unit> function1) {.swift
for (boolean valueOf : zArr) {.swift
function1.invoke(Boolean.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(boolean[] zArr, Function2<? super Integer, ? super Boolean, Unit> function2) {.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Boolean.valueOf(zArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static final IntRange getIndices(boolean[] zArr) {.swift
return new IntRange(0, getLastIndex(zArr));.swift
}.swift
public static final int getLastIndex(boolean[] zArr) {.swift
return zArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final boolean getOrElse(boolean[] zArr, int i, Function1<? super Integer, Boolean> function1) {.swift
return (i < 0 || i >= zArr.length) ? function1.invoke(Integer.valueOf(i)).booleanValue() : zArr[i];.swift
}.swift
public static final Boolean getOrNull(boolean[] zArr, int i) {.swift
if (i < 0 || i >= zArr.length) {.swift
return null;.swift
}.swift
return Boolean.valueOf(zArr[i]);.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(boolean[] zArr) {.swift
return zArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(boolean[] zArr) {.swift
return (zArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(boolean[] zArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(zArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Boolean, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(boolean[] zArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Boolean, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(zArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(boolean[] zArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(zArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Boolean, ? extends CharSequence>) function1);.swift
}.swift
public static final Boolean lastOrNull(boolean[] zArr) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
return Boolean.valueOf(zArr[zArr.length - 1]);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Byte maxByOrNull(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex == 0) {.swift
return Byte.valueOf(b);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Byte.valueOf(b));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Byte.valueOf(b2));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
b = b2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Byte minByOrNull(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex == 0) {.swift
return Byte.valueOf(b);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Byte.valueOf(b));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Byte.valueOf(b2));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
b = b2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
public static final boolean none(boolean[] zArr) {.swift
return zArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final boolean[] onEach(boolean[] zArr, Function1<? super Boolean, Unit> function1) {.swift
for (boolean valueOf : zArr) {.swift
function1.invoke(Boolean.valueOf(valueOf));.swift
}.swift
return zArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final boolean[] onEachIndexed(boolean[] zArr, Function2<? super Integer, ? super Boolean, Unit> function2) {.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Boolean.valueOf(zArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return zArr;.swift
}.swift
public static final Pair<List<Byte>, List<Byte>> partition(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
ArrayList arrayList2 = new ArrayList();.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
arrayList.add(Byte.valueOf(b));.swift
} else {.swift
arrayList2.add(Byte.valueOf(b));.swift
}.swift
}.swift
return new Pair<>(arrayList, arrayList2);.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final boolean random(boolean[] zArr) {.swift
return random(zArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Boolean randomOrNull(boolean[] zArr) {.swift
return randomOrNull(zArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short reduceRightIndexedOrNull(short[] sArr, Function3<? super Integer, ? super Short, ? super Short, Short> function3) {.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
short s = sArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
s = function3.invoke(Integer.valueOf(i), Short.valueOf(sArr[i]), Short.valueOf(s)).shortValue();.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short reduceRightOrNull(short[] sArr, Function2<? super Short, ? super Short, Short> function2) {.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
short s = sArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
s = function2.invoke(Short.valueOf(sArr[i]), Short.valueOf(s)).shortValue();.swift
}.swift
return Short.valueOf(s);.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Character, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scan(char[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Character, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
char r3 = r4[r2].swift
java.lang.Character r3 = java.lang.Character.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r4 = r0.swift
L_0x0028:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(char[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Character, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> scanIndexed(char[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Character, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x002c.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
char r4 = r5[r2].swift
java.lang.Character r4 = java.lang.Character.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
r5 = r0.swift
L_0x002c:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(char[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(boolean[] zArr) {.swift
shuffle(zArr, (Random) Random.Default);.swift
}.swift
public static final Boolean singleOrNull(boolean[] zArr) {.swift
if (zArr.length == 1) {.swift
return Boolean.valueOf(zArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final void sortDescending(int[] iArr) {.swift
if (iArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(iArr);.swift
reverse(iArr);.swift
}.swift
}.swift
public static final List<Character> sorted(char[] cArr) {.swift
Character[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(cArr);.swift
ArraysKt___ArraysJvmKt.sort((T[]) (Comparable[]) typedArray);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final <R extends Comparable<? super R>> List<Boolean> sortedBy(boolean[] zArr, Function1<? super Boolean, ? extends R> function1) {.swift
return sortedWith(zArr, (Comparator<? super Boolean>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Boolean> sortedByDescending(boolean[] zArr, Function1<? super Boolean, ? extends R> function1) {.swift
return sortedWith(zArr, (Comparator<? super Boolean>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Character> sortedDescending(char[] cArr) {.swift
char[] copyOf = Arrays.copyOf(cArr, cArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return reversed(copyOf);.swift
}.swift
public static final List<Boolean> sortedWith(boolean[] zArr, Comparator<? super Boolean> comparator) {.swift
Boolean[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(zArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final HashSet<Boolean> toHashSet(boolean[] zArr) {.swift
return (HashSet) toCollection(zArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(zArr.length)));.swift
}.swift
public static final List<Long> toMutableList(long[] jArr) {.swift
ArrayList arrayList = new ArrayList(jArr.length);.swift
for (long valueOf : jArr) {.swift
arrayList.add(Long.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final Set<Boolean> toMutableSet(boolean[] zArr) {.swift
return (Set) toCollection(zArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(zArr.length)));.swift
}.swift
public static final Iterable<IndexedValue<Boolean>> withIndex(boolean[] zArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$8(zArr));.swift
}.swift
public static final boolean all(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (char valueOf : cArr) {.swift
if (function1.invoke(Character.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final boolean any(char[] cArr) {.swift
return (cArr.length == 0);.swift
}.swift
public static final Iterable<Long> asIterable(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$5(jArr);.swift
}.swift
public static final Sequence<Long> asSequence(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$5(jArr);.swift
}.swift
public static final <K, V> Map<K, V> associate(short[] sArr, Function1<? super Short, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(sArr.length), 16));.swift
for (short valueOf : sArr) {.swift
Pair pair = (Pair) function1.invoke(Short.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Short> associateBy(short[] sArr, Function1<? super Short, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(sArr.length), 16));.swift
for (short s : sArr) {.swift
linkedHashMap.put(function1.invoke(Short.valueOf(s)), Short.valueOf(s));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, M extends Map<? super K, ? super Long>> M associateByTo(long[] jArr, M m, Function1<? super Long, ? extends K> function1) {.swift
for (long j : jArr) {.swift
m.put(function1.invoke(Long.valueOf(j)), Long.valueOf(j));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(long[] jArr, M m, Function1<? super Long, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (long valueOf : jArr) {.swift
Pair pair = (Pair) function1.invoke(Long.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Long, ? super V>> M associateWithTo(long[] jArr, M m, Function1<? super Long, ? extends V> function1) {.swift
for (long j : jArr) {.swift
m.put(Long.valueOf(j), function1.invoke(Long.valueOf(j)));.swift
}.swift
return m;.swift
}.swift
@InlineOnly.swift
private static final char component1(char[] cArr) {.swift
return cArr[0];.swift
}.swift
@InlineOnly.swift
private static final char component2(char[] cArr) {.swift
return cArr[1];.swift
}.swift
@InlineOnly.swift
private static final char component3(char[] cArr) {.swift
return cArr[2];.swift
}.swift
@InlineOnly.swift
private static final char component4(char[] cArr) {.swift
return cArr[3];.swift
}.swift
@InlineOnly.swift
private static final char component5(char[] cArr) {.swift
return cArr[4];.swift
}.swift
@Deprecated(message = "The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.", replaceWith = @ReplaceWith(expression = "any { it == element }", imports = {})).swift
@DeprecatedSinceKotlin(errorSince = "1.6", hiddenSince = "1.7", warningSince = "1.4").swift
public static final /* synthetic */ boolean contains(double[] dArr, double d) {.swift
for (double d2 : dArr) {.swift
if (d2 == d) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@InlineOnly.swift
private static final int count(char[] cArr) {.swift
return cArr.length;.swift
}.swift
public static final List<Character> distinct(char[] cArr) {.swift
return CollectionsKt___CollectionsKt.toList(toMutableSet(cArr));.swift
}.swift
public static final List<Short> dropLastWhile(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(sArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Short.valueOf(sArr[lastIndex])).booleanValue()) {.swift
return take(sArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
@InlineOnly.swift
private static final char elementAtOrElse(char[] cArr, int i, Function1<? super Integer, Character> function1) {.swift
return (i < 0 || i >= cArr.length) ? function1.invoke(Integer.valueOf(i)).charValue() : cArr[i];.swift
}.swift
@InlineOnly.swift
private static final Character elementAtOrNull(char[] cArr, int i) {.swift
return getOrNull(cArr, i);.swift
}.swift
public static final List<Long> filter(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Long>> C filterIndexedTo(long[] jArr, C c, Function2<? super Integer, ? super Long, Boolean> function2) {.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
long j = jArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Long.valueOf(j)).booleanValue()) {.swift
c.add(Long.valueOf(j));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Long> filterNot(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Character>> C filterNotTo(char[] cArr, C c, Function1<? super Character, Boolean> function1) {.swift
for (char c2 : cArr) {.swift
if (function1.invoke(Character.valueOf(c2)).booleanValue()) {.swift
c.add(Character.valueOf(c2));.swift
}.swift
}.swift
return c;.swift
}.swift
public static final <C extends Collection<? super Character>> C filterTo(char[] cArr, C c, Function1<? super Character, Boolean> function1) {.swift
for (char c2 : cArr) {.swift
if (function1.invoke(Character.valueOf(c2)).booleanValue()) {.swift
c.add(Character.valueOf(c2));.swift
}.swift
}.swift
return c;.swift
}.swift
@InlineOnly.swift
private static final Character find(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (char c : cArr) {.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
return Character.valueOf(c);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final Character firstOrNull(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return null;.swift
}.swift
return Character.valueOf(cArr[0]);.swift
}.swift
public static final <R> List<R> flatMap(short[] sArr, Function1<? super Short, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (short valueOf : sArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Short.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterable").swift
private static final <R> List<R> flatMapIndexedIterable(char[] cArr, Function2<? super Integer, ? super Character, ? extends Iterable<? extends R>> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function2.invoke(Integer.valueOf(i2), Character.valueOf(cArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Character, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R fold(char[] r3, R r4, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Character, ? extends R> r5) {.swift
/*.swift
int r0 = r3.length.swift
r1 = 0.swift
L_0x0002:.swift
if (r1 >= r0) goto L_0x0011.swift
char r2 = r3[r1].swift
java.lang.Character r2 = java.lang.Character.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r4, r2).swift
int r1 = r1 + 1.swift
goto L_0x0002.swift
L_0x0011:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.fold(char[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Character, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldIndexed(char[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Character, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
r1 = 0.swift
r2 = r1.swift
L_0x0003:.swift
if (r1 >= r0) goto L_0x0019.swift
char r3 = r5[r1].swift
int r4 = r2 + 1.swift
java.lang.Integer r2 = java.lang.Integer.valueOf(r2).swift
java.lang.Character r3 = java.lang.Character.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r2, r6, r3).swift
int r1 = r1 + 1.swift
r2 = r4.swift
goto L_0x0003.swift
L_0x0019:.swift
return r6.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldIndexed(char[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Long, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(long[] r4, R r5, kotlin.jvm.functions.Function2<? super java.lang.Long, ? super R, ? extends R> r6) {.swift
/*.swift
int r0 = getLastIndex((long[]) r4).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
r2 = r4[r0].swift
java.lang.Long r0 = java.lang.Long.valueOf(r2).swift
java.lang.Object r5 = r6.invoke(r0, r5).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(long[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Long, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(long[] r4, R r5, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Long, ? super R, ? extends R> r6) {.swift
/*.swift
int r0 = getLastIndex((long[]) r4).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
r2 = r4[r0].swift
java.lang.Long r2 = java.lang.Long.valueOf(r2).swift
java.lang.Object r5 = r6.invoke(r1, r2, r5).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(long[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final void forEach(char[] cArr, Function1<? super Character, Unit> function1) {.swift
for (char valueOf : cArr) {.swift
function1.invoke(Character.valueOf(valueOf));.swift
}.swift
}.swift
public static final void forEachIndexed(char[] cArr, Function2<? super Integer, ? super Character, Unit> function2) {.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Character.valueOf(cArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
}.swift
public static final IntRange getIndices(char[] cArr) {.swift
return new IntRange(0, getLastIndex(cArr));.swift
}.swift
public static final int getLastIndex(char[] cArr) {.swift
return cArr.length - 1;.swift
}.swift
@InlineOnly.swift
private static final char getOrElse(char[] cArr, int i, Function1<? super Integer, Character> function1) {.swift
return (i < 0 || i >= cArr.length) ? function1.invoke(Integer.valueOf(i)).charValue() : cArr[i];.swift
}.swift
public static final Character getOrNull(char[] cArr, int i) {.swift
if (i < 0 || i >= cArr.length) {.swift
return null;.swift
}.swift
return Character.valueOf(cArr[i]);.swift
}.swift
public static int indexOf(int[] iArr, int i) {.swift
int length = iArr.length;.swift
for (int i2 = 0; i2 < length; i2++) {.swift
if (i == iArr[i2]) {.swift
return i2;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
int length = jArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Long.valueOf(jArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
int length = jArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Long.valueOf(jArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Long> intersect(long[] jArr, Iterable<Long> iterable) {.swift
Set<Long> mutableSet = toMutableSet(jArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@InlineOnly.swift
private static final boolean isEmpty(char[] cArr) {.swift
return cArr.length == 0;.swift
}.swift
@InlineOnly.swift
private static final boolean isNotEmpty(char[] cArr) {.swift
return (cArr.length == 0);.swift
}.swift
public static /* synthetic */ Appendable joinTo$default(char[] cArr, Appendable appendable, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
String str = (i2 & 2)  charSequence;.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 4)  charSequence2;.swift
if ((i2 & 8) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
return joinTo(cArr, appendable, str, charSequence6, charSequence5, (i2 & 16)  i, (i2 & 32)  charSequence4, (Function1<? super Character, ? extends CharSequence>) (i2 & 64)  function1);.swift
}.swift
public static final String joinToString(char[] cArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Character, ? extends CharSequence> function1) {.swift
return ((StringBuilder) joinTo(cArr, new StringBuilder(), charSequence, charSequence2, charSequence3, i, charSequence4, function1)).toString();.swift
}.swift
public static /* synthetic */ String joinToString$default(char[] cArr, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1 function1, int i2, Object obj) {.swift
if ((i2 & 1) = 0) {.swift
charSequence = ", ";.swift
}.swift
CharSequence charSequence5 = "";.swift
CharSequence charSequence6 = (i2 & 2)  charSequence2;.swift
if ((i2 & 4) == 0) {.swift
charSequence5 = charSequence3;.swift
}.swift
if ((i2 & 8) = 0) {.swift
i = -1;.swift
}.swift
int i3 = i;.swift
if ((i2 & 16) = 0) {.swift
charSequence4 = "...";.swift
}.swift
CharSequence charSequence7 = charSequence4;.swift
if ((i2 & 32) = 0) {.swift
function1 = null;.swift
}.swift
return joinToString(cArr, charSequence, charSequence6, charSequence5, i3, charSequence7, (Function1<? super Character, ? extends CharSequence>) function1);.swift
}.swift
public static int lastIndexOf(int[] iArr, int i) {.swift
int length = iArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i2 = length - 1;.swift
if (i == iArr[length]) {.swift
return length;.swift
}.swift
if (i2 < 0) {.swift
break;.swift
}.swift
length = i2;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Character lastOrNull(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return null;.swift
}.swift
return Character.valueOf(cArr[cArr.length - 1]);.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(long[] jArr, C c, Function2<? super Integer, ? super Long, ? extends R> function2) {.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Long.valueOf(jArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(long[] jArr, C c, Function1<? super Long, ? extends R> function1) {.swift
for (long valueOf : jArr) {.swift
c.add(function1.invoke(Long.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxByOrThrow").swift
public static final <R extends Comparable<? super R>> byte maxByOrThrow(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex == 0) {.swift
return b;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Byte.valueOf(b));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Byte.valueOf(b2));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
b = b2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minByOrThrow").swift
public static final <R extends Comparable<? super R>> byte minByOrThrow(byte[] bArr, Function1<? super Byte, ? extends R> function1) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
if (lastIndex == 0) {.swift
return b;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Byte.valueOf(b));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Byte.valueOf(b2));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
b = b2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
public static final boolean none(char[] cArr) {.swift
return cArr.length == 0;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final char[] onEach(char[] cArr, Function1<? super Character, Unit> function1) {.swift
for (char valueOf : cArr) {.swift
function1.invoke(Character.valueOf(valueOf));.swift
}.swift
return cArr;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final char[] onEachIndexed(char[] cArr, Function2<? super Integer, ? super Character, Unit> function2) {.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
function2.invoke(Integer.valueOf(i2), Character.valueOf(cArr[i]));.swift
i++;.swift
i2++;.swift
}.swift
return cArr;.swift
}.swift
@SinceKotlin(version = "1.3").swift
@InlineOnly.swift
private static final char random(char[] cArr) {.swift
return random(cArr, (Random) Random.Default);.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final Character randomOrNull(char[] cArr) {.swift
return randomOrNull(cArr, (Random) Random.Default);.swift
}.swift
public static final short reduceRight(short[] sArr, Function2<? super Short, ? super Short, Short> function2) {.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex >= 0) {.swift
short s = sArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
s = function2.invoke(Short.valueOf(sArr[i]), Short.valueOf(s)).shortValue();.swift
}.swift
return s;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final short reduceRightIndexed(short[] sArr, Function3<? super Integer, ? super Short, ? super Short, Short> function3) {.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex >= 0) {.swift
short s = sArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
s = function3.invoke(Integer.valueOf(i), Short.valueOf(sArr[i]), Short.valueOf(s)).shortValue();.swift
}.swift
return s;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static short[] reversedArray(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return sArr;.swift
}.swift
short[] sArr2 = new short[sArr.length];.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
sArr2[lastIndex - i] = sArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return sArr2;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super T, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> java.util.List<R> scan(T[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super T, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
goto L_0x0024.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0023.swift
r3 = r4[r2].swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0023:.swift
r4 = r0.swift
L_0x0024:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scan(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super T, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <T, R> java.util.List<R> scanIndexed(T[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super T, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
goto L_0x0028.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
r5 = r0.swift
L_0x0028:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.scanIndexed(java.lang.Object[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(char[] cArr) {.swift
shuffle(cArr, (Random) Random.Default);.swift
}.swift
public static short single(short[] sArr) {.swift
int length = sArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return sArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final Character singleOrNull(char[] cArr) {.swift
if (cArr.length == 1) {.swift
return Character.valueOf(cArr[0]);.swift
}.swift
return null;.swift
}.swift
public static final long[] sortedArray(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return jArr;.swift
}.swift
long[] copyOf = Arrays.copyOf(jArr, jArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final long[] sortedArrayDescending(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return jArr;.swift
}.swift
long[] copyOf = Arrays.copyOf(jArr, jArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final <R extends Comparable<? super R>> List<Character> sortedBy(char[] cArr, Function1<? super Character, ? extends R> function1) {.swift
return sortedWith(cArr, (Comparator<? super Character>) new ComparisonsKt__ComparisonsKt$compareBy$2(function1));.swift
}.swift
public static final <R extends Comparable<? super R>> List<Character> sortedByDescending(char[] cArr, Function1<? super Character, ? extends R> function1) {.swift
return sortedWith(cArr, (Comparator<? super Character>) new ComparisonsKt__ComparisonsKt$compareByDescending$1(function1));.swift
}.swift
public static final List<Character> sortedWith(char[] cArr, Comparator<? super Character> comparator) {.swift
Character[] typedArray = ArraysKt___ArraysJvmKt.toTypedArray(cArr);.swift
ArraysKt___ArraysJvmKt.sortWith(typedArray, comparator);.swift
return ArraysKt___ArraysJvmKt.asList((T[]) typedArray);.swift
}.swift
public static final Set<Long> subtract(long[] jArr, Iterable<Long> iterable) {.swift
Set<Long> mutableSet = toMutableSet(jArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(long[] jArr, Function1<? super Long, Integer> function1) {.swift
int i = 0;.swift
for (long valueOf : jArr) {.swift
i += function1.invoke(Long.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(long[] jArr, Function1<? super Long, Double> function1) {.swift
double d = 0.0d;.swift
for (long valueOf : jArr) {.swift
d += function1.invoke(Long.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(long[] jArr, Function1<? super Long, Double> function1) {.swift
double d = 0.0d;.swift
for (long valueOf : jArr) {.swift
d += function1.invoke(Long.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(long[] jArr, Function1<? super Long, Integer> function1) {.swift
int i = 0;.swift
for (long valueOf : jArr) {.swift
i += function1.invoke(Long.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(long[] jArr, Function1<? super Long, Long> function1) {.swift
long j = 0;.swift
for (long valueOf : jArr) {.swift
j += function1.invoke(Long.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
public static final List<Short> takeLastWhile(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(sArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Short.valueOf(sArr[lastIndex])).booleanValue()) {.swift
return drop(sArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(sArr);.swift
}.swift
public static final List<Short> takeWhile(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Long>> C toCollection(long[] jArr, C c) {.swift
for (long valueOf : jArr) {.swift
c.add(Long.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final HashSet<Character> toHashSet(char[] cArr) {.swift
return (HashSet) toCollection(cArr, new HashSet(MapsKt__MapsJVMKt.mapCapacity(RangesKt.coerceAtMost(cArr.length, (int) Uuid.SIZE_BITS))));.swift
}.swift
public static final List<Short> toList(short[] sArr) {.swift
int length = sArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(sArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Short.valueOf(sArr[0]));.swift
}.swift
public static final Set<Character> toMutableSet(char[] cArr) {.swift
return (Set) toCollection(cArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(RangesKt.coerceAtMost(cArr.length, (int) Uuid.SIZE_BITS))));.swift
}.swift
public static final Set<Short> toSet(short[] sArr) {.swift
int length = sArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(sArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(sArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Short.valueOf(sArr[0]));.swift
}.swift
public static final Set<Long> union(long[] jArr, Iterable<Long> iterable) {.swift
Set<Long> mutableSet = toMutableSet(jArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final Iterable<IndexedValue<Character>> withIndex(char[] cArr) {.swift
return new IndexingIterable(new ArraysKt___ArraysKt$withIndex$9(cArr));.swift
}.swift
public static final <T> boolean any(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (T invoke : tArr) {.swift
if (function1.invoke(invoke).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Long, V> associateWith(long[] jArr, Function1<? super Long, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(jArr.length), 16));.swift
for (long j : jArr) {.swift
linkedHashMap.put(Long.valueOf(j), function1.invoke(Long.valueOf(j)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <T> int count(T[] tArr, Function1<? super T, Boolean> function1) {.swift
int i = 0;.swift
for (T invoke : tArr) {.swift
if (function1.invoke(invoke).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final List<Byte> drop(byte[] bArr, int i) {.swift
if (i >= 0) {.swift
return takeLast(bArr, RangesKt.coerceAtLeast(bArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final List<Byte> dropLast(byte[] bArr, int i) {.swift
if (i >= 0) {.swift
return take(bArr, RangesKt.coerceAtLeast(bArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final List<Integer> filterIndexed(int[] iArr, Function2<? super Integer, ? super Integer, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
int i3 = iArr[i];.swift
int i4 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Integer.valueOf(i3)).booleanValue()) {.swift
arrayList.add(Integer.valueOf(i3));.swift
}.swift
i++;.swift
i2 = i4;.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final Integer findLast(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
int length = iArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
int i2 = iArr[length];.swift
if (function1.invoke(Integer.valueOf(i2)).booleanValue()) {.swift
return Integer.valueOf(i2);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static int first(int[] iArr) {.swift
if (iArr.length = 0) {.swift
return iArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static <T> T firstOrNull(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
return t;.swift
}.swift
}.swift
return null;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(int[] iArr, C c, Function2<? super Integer, ? super Integer, ? extends Iterable<? extends R>> function2) {.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(int[] iArr, C c, Function1<? super Integer, ? extends Iterable<? extends R>> function1) {.swift
for (int valueOf : iArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Integer.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final <K, M extends Map<? super K, List<Byte>>> M groupByTo(byte[] bArr, M m, Function1<? super Byte, ? extends K> function1) {.swift
for (byte b : bArr) {.swift
Object invoke = function1.invoke(Byte.valueOf(b));.swift
Object obj = m.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.r(m, invoke);.swift
}.swift
((List) obj).add(Byte.valueOf(b));.swift
}.swift
return m;.swift
}.swift
public static int last(int[] iArr) {.swift
if (iArr.length = 0) {.swift
return iArr[getLastIndex(iArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final <T> T lastOrNull(T[] tArr, Function1<? super T, Boolean> function1) {.swift
int length = tArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
T t = tArr[length];.swift
if (function1.invoke(t).booleanValue()) {.swift
return t;.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
public static final <R> List<R> map(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(iArr.length);.swift
for (int valueOf : iArr) {.swift
arrayList.add(function1.invoke(Integer.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(int[] iArr, Function2<? super Integer, ? super Integer, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(iArr.length);.swift
int length = iArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <T> boolean none(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (T invoke : tArr) {.swift
if (function1.invoke(invoke).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static <T> T random(T[] tArr, Random random) {.swift
if (tArr.length = 0) {.swift
return tArr[random.nextInt(tArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T> T randomOrNull(T[] tArr, Random random) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
return tArr[random.nextInt(tArr.length)];.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short reduceIndexedOrNull(short[] sArr, Function3<? super Integer, ? super Short, ? super Short, Short> function3) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
s = function3.invoke(Integer.valueOf(i), Short.valueOf(s), Short.valueOf(sArr[i])).shortValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short reduceOrNull(short[] sArr, Function2<? super Short, ? super Short, Short> function2) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
s = function2.invoke(Short.valueOf(s), Short.valueOf(sArr[i])).shortValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
public static final List<Integer> reversed(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Integer> mutableList = toMutableList(iArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T> void shuffle(T[] tArr, Random random) {.swift
for (int lastIndex = getLastIndex(tArr); lastIndex > 0; lastIndex--) {.swift
int nextInt = random.nextInt(lastIndex + 1);.swift
T t = tArr[lastIndex];.swift
tArr[lastIndex] = tArr[nextInt];.swift
tArr[nextInt] = t;.swift
}.swift
}.swift
public static final <T> T singleOrNull(T[] tArr, Function1<? super T, Boolean> function1) {.swift
T t = null;.swift
boolean z = false;.swift
for (T t2 : tArr) {.swift
if (function1.invoke(t2).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
z = true;.swift
t = t2;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return t;.swift
}.swift
public static int[] sliceArray(int[] iArr, Collection<Integer> collection) {.swift
int[] iArr2 = new int[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
iArr2[i] = iArr[intValue.intValue()];.swift
i++;.swift
}.swift
return iArr2;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(int[] iArr, Function1<? super Integer, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (int valueOf : iArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Integer.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final List<Float> toMutableList(float[] fArr) {.swift
ArrayList arrayList = new ArrayList(fArr.length);.swift
for (float valueOf : fArr) {.swift
arrayList.add(Float.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R, V> List<V> zip(int[] iArr, R[] rArr, Function2<? super Integer, ? super R, ? extends V> function2) {.swift
int min = Math.min(iArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Integer.valueOf(iArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean any(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (byte valueOf : bArr) {.swift
if (function1.invoke(Byte.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
public static final Iterable<Float> asIterable(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$6(fArr);.swift
}.swift
public static Sequence<Float> asSequence(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$6(fArr);.swift
}.swift
public static final <K, M extends Map<? super K, ? super Float>> M associateByTo(float[] fArr, M m, Function1<? super Float, ? extends K> function1) {.swift
for (float f : fArr) {.swift
m.put(function1.invoke(Float.valueOf(f)), Float.valueOf(f));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(float[] fArr, M m, Function1<? super Float, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (float valueOf : fArr) {.swift
Pair pair = (Pair) function1.invoke(Float.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Float, ? super V>> M associateWithTo(float[] fArr, M m, Function1<? super Float, ? extends V> function1) {.swift
for (float f : fArr) {.swift
m.put(Float.valueOf(f), function1.invoke(Float.valueOf(f)));.swift
}.swift
return m;.swift
}.swift
public static final int count(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
int i = 0;.swift
for (byte valueOf : bArr) {.swift
if (function1.invoke(Byte.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final List<Short> dropWhile(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (short s : sArr) {.swift
if (z) {.swift
arrayList.add(Short.valueOf(s));.swift
} else if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
arrayList.add(Short.valueOf(s));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Float> filter(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Float>> C filterIndexedTo(float[] fArr, C c, Function2<? super Integer, ? super Float, Boolean> function2) {.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
float f = fArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Float.valueOf(f)).booleanValue()) {.swift
c.add(Float.valueOf(f));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Float> filterNot(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final Byte firstOrNull(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
return Byte.valueOf(b);.swift
}.swift
}.swift
return null;.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Float, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(float[] r2, R r3, kotlin.jvm.functions.Function2<? super java.lang.Float, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((float[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
r0 = r2[r0].swift
java.lang.Float r0 = java.lang.Float.valueOf(r0).swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(float[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Float, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(float[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Float, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((float[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
r2 = r3[r0].swift
java.lang.Float r2 = java.lang.Float.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(float[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final <K> Map<K, List<Byte>> groupBy(byte[] bArr, Function1<? super Byte, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap();.swift
for (byte b : bArr) {.swift
Object invoke = function1.invoke(Byte.valueOf(b));.swift
Object obj = linkedHashMap.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.q(linkedHashMap, invoke);.swift
}.swift
((List) obj).add(Byte.valueOf(b));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static int indexOf(long[] jArr, long j) {.swift
int length = jArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (j == jArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
int length = fArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Float.valueOf(fArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
int length = fArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Float.valueOf(fArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Float> intersect(float[] fArr, Iterable<Float> iterable) {.swift
Set<Float> mutableSet = toMutableSet(fArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static int lastIndexOf(long[] jArr, long j) {.swift
int length = jArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (j == jArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(float[] fArr, C c, Function2<? super Integer, ? super Float, ? extends R> function2) {.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Float.valueOf(fArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(float[] fArr, C c, Function1<? super Float, ? extends R> function1) {.swift
for (float valueOf : fArr) {.swift
c.add(function1.invoke(Float.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(short[] sArr, Comparator<? super R> comparator, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Short.valueOf(sArr[0]));.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Short.valueOf(sArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(short[] sArr, Comparator<? super R> comparator, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Short.valueOf(sArr[0]));.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Short.valueOf(sArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
public static final boolean none(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (byte valueOf : bArr) {.swift
if (function1.invoke(Byte.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final short reduce(short[] sArr, Function2<? super Short, ? super Short, Short> function2) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
s = function2.invoke(Short.valueOf(s), Short.valueOf(sArr[i])).shortValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final short reduceIndexed(short[] sArr, Function3<? super Integer, ? super Short, ? super Short, Short> function3) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
s = function3.invoke(Integer.valueOf(i), Short.valueOf(s), Short.valueOf(sArr[i])).shortValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static void reverse(short[] sArr) {.swift
int length = (sArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(sArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
short s = sArr[i];.swift
sArr[i] = sArr[lastIndex];.swift
sArr[lastIndex] = s;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Short, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(short[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Short, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
return r4.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
short r3 = r4[r2].swift
java.lang.Short r3 = java.lang.Short.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(short[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Short, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(short[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Short, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
short r4 = r5[r2].swift
java.lang.Short r4 = java.lang.Short.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(short[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
public static final void sortDescending(long[] jArr) {.swift
if (jArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(jArr);.swift
reverse(jArr);.swift
}.swift
}.swift
public static final float[] sortedArray(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return fArr;.swift
}.swift
float[] copyOf = Arrays.copyOf(fArr, fArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final float[] sortedArrayDescending(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return fArr;.swift
}.swift
float[] copyOf = Arrays.copyOf(fArr, fArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final Set<Float> subtract(float[] fArr, Iterable<Float> iterable) {.swift
Set<Float> mutableSet = toMutableSet(fArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(float[] fArr, Function1<? super Float, Integer> function1) {.swift
int i = 0;.swift
for (float valueOf : fArr) {.swift
i += function1.invoke(Float.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(float[] fArr, Function1<? super Float, Double> function1) {.swift
double d = 0.0d;.swift
for (float valueOf : fArr) {.swift
d += function1.invoke(Float.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(float[] fArr, Function1<? super Float, Double> function1) {.swift
double d = 0.0d;.swift
for (float valueOf : fArr) {.swift
d += function1.invoke(Float.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(float[] fArr, Function1<? super Float, Integer> function1) {.swift
int i = 0;.swift
for (float valueOf : fArr) {.swift
i += function1.invoke(Float.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(float[] fArr, Function1<? super Float, Long> function1) {.swift
long j = 0;.swift
for (float valueOf : fArr) {.swift
j += function1.invoke(Float.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
public static final <C extends Collection<? super Float>> C toCollection(float[] fArr, C c) {.swift
for (float valueOf : fArr) {.swift
c.add(Float.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final Set<Float> union(float[] fArr, Iterable<Float> iterable) {.swift
Set<Float> mutableSet = toMutableSet(fArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final boolean any(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (short valueOf : sArr) {.swift
if (function1.invoke(Short.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Float, V> associateWith(float[] fArr, Function1<? super Float, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(fArr.length), 16));.swift
for (float f : fArr) {.swift
linkedHashMap.put(Float.valueOf(f), function1.invoke(Float.valueOf(f)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final int count(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
int i = 0;.swift
for (short valueOf : sArr) {.swift
if (function1.invoke(Short.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final Short firstOrNull(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
return Short.valueOf(s);.swift
}.swift
}.swift
return null;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short maxWithOrNull(short[] sArr, Comparator<? super Short> comparator) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (comparator.compare(Short.valueOf(s), Short.valueOf(s2)) < 0) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short minWithOrNull(short[] sArr, Comparator<? super Short> comparator) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (comparator.compare(Short.valueOf(s), Short.valueOf(s2)) > 0) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
public static final boolean none(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (short valueOf : sArr) {.swift
if (function1.invoke(Short.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte randomOrNull(byte[] bArr, Random random) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
return Byte.valueOf(bArr[random.nextInt(bArr.length)]);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer reduceRightIndexedOrNull(int[] iArr, Function3<? super Integer, ? super Integer, ? super Integer, Integer> function3) {.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
int i = iArr[lastIndex];.swift
for (int i2 = lastIndex - 1; i2 >= 0; i2--) {.swift
i = function3.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i2]), Integer.valueOf(i)).intValue();.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer reduceRightOrNull(int[] iArr, Function2<? super Integer, ? super Integer, Integer> function2) {.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
int i = iArr[lastIndex];.swift
for (int i2 = lastIndex - 1; i2 >= 0; i2--) {.swift
i = function2.invoke(Integer.valueOf(iArr[i2]), Integer.valueOf(i)).intValue();.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
public static final Byte singleOrNull(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
Byte b = null;.swift
boolean z = false;.swift
for (byte b2 : bArr) {.swift
if (function1.invoke(Byte.valueOf(b2)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
b = Byte.valueOf(b2);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return b;.swift
}.swift
public static final List<Double> toMutableList(double[] dArr) {.swift
ArrayList arrayList = new ArrayList(dArr.length);.swift
for (double valueOf : dArr) {.swift
arrayList.add(Double.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean any(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int valueOf : iArr) {.swift
if (function1.invoke(Integer.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
public static final Iterable<Double> asIterable(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$7(dArr);.swift
}.swift
public static final Sequence<Double> asSequence(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$7(dArr);.swift
}.swift
public static final <K, V> Map<K, V> associate(int[] iArr, Function1<? super Integer, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(iArr.length), 16));.swift
for (int valueOf : iArr) {.swift
Pair pair = (Pair) function1.invoke(Integer.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Integer> associateBy(int[] iArr, Function1<? super Integer, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(iArr.length), 16));.swift
for (int i : iArr) {.swift
linkedHashMap.put(function1.invoke(Integer.valueOf(i)), Integer.valueOf(i));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, M extends Map<? super K, ? super Double>> M associateByTo(double[] dArr, M m, Function1<? super Double, ? extends K> function1) {.swift
for (double d : dArr) {.swift
m.put(function1.invoke(Double.valueOf(d)), Double.valueOf(d));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(double[] dArr, M m, Function1<? super Double, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (double valueOf : dArr) {.swift
Pair pair = (Pair) function1.invoke(Double.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Double, ? super V>> M associateWithTo(double[] dArr, M m, Function1<? super Double, ? extends V> function1) {.swift
for (double d : dArr) {.swift
m.put(Double.valueOf(d), function1.invoke(Double.valueOf(d)));.swift
}.swift
return m;.swift
}.swift
public static final int count(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
int i = 0;.swift
for (int valueOf : iArr) {.swift
if (function1.invoke(Integer.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final <K> List<Short> distinctBy(short[] sArr, Function1<? super Short, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (short s : sArr) {.swift
if (hashSet.add(function1.invoke(Short.valueOf(s)))) {.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Integer> dropLastWhile(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(iArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Integer.valueOf(iArr[lastIndex])).booleanValue()) {.swift
return take(iArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final List<Double> filter(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Long> filterIndexed(long[] jArr, Function2<? super Integer, ? super Long, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
long j = jArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Long.valueOf(j)).booleanValue()) {.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Double>> C filterIndexedTo(double[] dArr, C c, Function2<? super Integer, ? super Double, Boolean> function2) {.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
double d = dArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Double.valueOf(d)).booleanValue()) {.swift
c.add(Double.valueOf(d));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Double> filterNot(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final Long findLast(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
int length = jArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
long j = jArr[length];.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
return Long.valueOf(j);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static long first(long[] jArr) {.swift
if (jArr.length = 0) {.swift
return jArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Integer firstOrNull(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
return Integer.valueOf(i);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final <R> List<R> flatMap(int[] iArr, Function1<? super Integer, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (int valueOf : iArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Integer.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(long[] jArr, C c, Function2<? super Integer, ? super Long, ? extends Iterable<? extends R>> function2) {.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Long.valueOf(jArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(long[] jArr, C c, Function1<? super Long, ? extends Iterable<? extends R>> function1) {.swift
for (long valueOf : jArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Long.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Double, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(double[] r4, R r5, kotlin.jvm.functions.Function2<? super java.lang.Double, ? super R, ? extends R> r6) {.swift
/*.swift
int r0 = getLastIndex((double[]) r4).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
r2 = r4[r0].swift
java.lang.Double r0 = java.lang.Double.valueOf(r2).swift
java.lang.Object r5 = r6.invoke(r0, r5).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(double[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Double, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(double[] r4, R r5, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Double, ? super R, ? extends R> r6) {.swift
/*.swift
int r0 = getLastIndex((double[]) r4).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
r2 = r4[r0].swift
java.lang.Double r2 = java.lang.Double.valueOf(r2).swift
java.lang.Object r5 = r6.invoke(r1, r2, r5).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r5.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(double[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
@Deprecated(message = "The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.", replaceWith = @ReplaceWith(expression = "indexOfFirst { it == element }", imports = {})).swift
@DeprecatedSinceKotlin(errorSince = "1.6", hiddenSince = "1.7", warningSince = "1.4").swift
public static final /* synthetic */ int indexOf(float[] fArr, float f) {.swift
int length = fArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (f == fArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
int length = dArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Double.valueOf(dArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
int length = dArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Double.valueOf(dArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Double> intersect(double[] dArr, Iterable<Double> iterable) {.swift
Set<Double> mutableSet = toMutableSet(dArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static long last(long[] jArr) {.swift
if (jArr.length = 0) {.swift
return jArr[getLastIndex(jArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@Deprecated(message = "The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.", replaceWith = @ReplaceWith(expression = "indexOfLast { it == element }", imports = {})).swift
@DeprecatedSinceKotlin(errorSince = "1.6", hiddenSince = "1.7", warningSince = "1.4").swift
public static final /* synthetic */ int lastIndexOf(float[] fArr, float f) {.swift
int length = fArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (f == fArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Byte lastOrNull(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
int length = bArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
byte b = bArr[length];.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
return Byte.valueOf(b);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
public static final <R> List<R> map(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(jArr.length);.swift
for (long valueOf : jArr) {.swift
arrayList.add(function1.invoke(Long.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(long[] jArr, Function2<? super Integer, ? super Long, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(jArr.length);.swift
int length = jArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Long.valueOf(jArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(double[] dArr, C c, Function2<? super Integer, ? super Double, ? extends R> function2) {.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Double.valueOf(dArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(double[] dArr, C c, Function1<? super Double, ? extends R> function1) {.swift
for (double valueOf : dArr) {.swift
c.add(function1.invoke(Double.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double maxOf(short[] sArr, Function1<? super Short, Double> function1) {.swift
if (sArr.length = 0) {.swift
double doubleValue = function1.invoke(Short.valueOf(sArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Short.valueOf(sArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final Double m403maxOfOrNull(short[] sArr, Function1<? super Short, Double> function1) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Short.valueOf(sArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Short.valueOf(sArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWith(short[] sArr, Comparator<? super R> comparator, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length = 0) {.swift
R invoke = function1.invoke(Short.valueOf(sArr[0]));.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Short.valueOf(sArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static <T extends Comparable<? super T>> T maxOrNull(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (t.compareTo(t2) < 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final <T extends Comparable<? super T>> T maxOrThrow(T[] tArr) {.swift
if (tArr.length = 0) {.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (t.compareTo(t2) < 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final short maxWithOrThrow(short[] sArr, Comparator<? super Short> comparator) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (comparator.compare(Short.valueOf(s), Short.valueOf(s2)) < 0) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double minOf(short[] sArr, Function1<? super Short, Double> function1) {.swift
if (sArr.length = 0) {.swift
double doubleValue = function1.invoke(Short.valueOf(sArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Short.valueOf(sArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final Double m439minOfOrNull(short[] sArr, Function1<? super Short, Double> function1) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Short.valueOf(sArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Short.valueOf(sArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWith(short[] sArr, Comparator<? super R> comparator, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length = 0) {.swift
R invoke = function1.invoke(Short.valueOf(sArr[0]));.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Short.valueOf(sArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T extends Comparable<? super T>> T minOrNull(T[] tArr) {.swift
if (tArr.length == 0) {.swift
return null;.swift
}.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (t.compareTo(t2) > 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final <T extends Comparable<? super T>> T minOrThrow(T[] tArr) {.swift
if (tArr.length = 0) {.swift
T t = tArr[0];.swift
int lastIndex = getLastIndex(tArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
T t2 = tArr[i];.swift
if (t.compareTo(t2) > 0) {.swift
t = t2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return t;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final short minWithOrThrow(short[] sArr, Comparator<? super Short> comparator) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (comparator.compare(Short.valueOf(s), Short.valueOf(s2)) > 0) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
public static final boolean none(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int valueOf : iArr) {.swift
if (function1.invoke(Integer.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final byte random(byte[] bArr, Random random) {.swift
if (bArr.length = 0) {.swift
return bArr[random.nextInt(bArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final int reduceRight(int[] iArr, Function2<? super Integer, ? super Integer, Integer> function2) {.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex >= 0) {.swift
int i = iArr[lastIndex];.swift
for (int i2 = lastIndex - 1; i2 >= 0; i2--) {.swift
i = function2.invoke(Integer.valueOf(iArr[i2]), Integer.valueOf(i)).intValue();.swift
}.swift
return i;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final int reduceRightIndexed(int[] iArr, Function3<? super Integer, ? super Integer, ? super Integer, Integer> function3) {.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex >= 0) {.swift
int i = iArr[lastIndex];.swift
for (int i2 = lastIndex - 1; i2 >= 0; i2--) {.swift
i = function3.invoke(Integer.valueOf(i2), Integer.valueOf(iArr[i2]), Integer.valueOf(i)).intValue();.swift
}.swift
return i;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final List<Long> reversed(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Long> mutableList = toMutableList(jArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
public static int[] reversedArray(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return iArr;.swift
}.swift
int[] iArr2 = new int[iArr.length];.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
iArr2[lastIndex - i] = iArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return iArr2;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Short> runningReduce(short[] sArr, Function2<? super Short, ? super Short, Short> function2) {.swift
if (sArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
short s = sArr[0];.swift
ArrayList arrayList = new ArrayList(sArr.length);.swift
arrayList.add(Short.valueOf(s));.swift
int length = sArr.length;.swift
for (int i = 1; i < length; i++) {.swift
s = function2.invoke(Short.valueOf(s), Short.valueOf(sArr[i])).shortValue();.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Short> runningReduceIndexed(short[] sArr, Function3<? super Integer, ? super Short, ? super Short, Short> function3) {.swift
if (sArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
short s = sArr[0];.swift
ArrayList arrayList = new ArrayList(sArr.length);.swift
arrayList.add(Short.valueOf(s));.swift
int length = sArr.length;.swift
for (int i = 1; i < length; i++) {.swift
s = function3.invoke(Integer.valueOf(i), Short.valueOf(s), Short.valueOf(sArr[i])).shortValue();.swift
arrayList.add(Short.valueOf(s));.swift
}.swift
return arrayList;.swift
}.swift
public static int single(int[] iArr) {.swift
int length = iArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return iArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final List<Short> slice(short[] sArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList(ArraysKt___ArraysJvmKt.copyOfRange(sArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
public static long[] sliceArray(long[] jArr, Collection<Integer> collection) {.swift
long[] jArr2 = new long[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
jArr2[i] = jArr[intValue.intValue()];.swift
i++;.swift
}.swift
return jArr2;.swift
}.swift
public static final double[] sortedArray(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return dArr;.swift
}.swift
double[] copyOf = Arrays.copyOf(dArr, dArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final double[] sortedArrayDescending(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return dArr;.swift
}.swift
double[] copyOf = Arrays.copyOf(dArr, dArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final Set<Double> subtract(double[] dArr, Iterable<Double> iterable) {.swift
Set<Double> mutableSet = toMutableSet(dArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(double[] dArr, Function1<? super Double, Integer> function1) {.swift
int i = 0;.swift
for (double valueOf : dArr) {.swift
i += function1.invoke(Double.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(double[] dArr, Function1<? super Double, Double> function1) {.swift
double d = 0.0d;.swift
for (double valueOf : dArr) {.swift
d += function1.invoke(Double.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(double[] dArr, Function1<? super Double, Double> function1) {.swift
double d = 0.0d;.swift
for (double valueOf : dArr) {.swift
d += function1.invoke(Double.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(double[] dArr, Function1<? super Double, Integer> function1) {.swift
int i = 0;.swift
for (double valueOf : dArr) {.swift
i += function1.invoke(Double.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(double[] dArr, Function1<? super Double, Long> function1) {.swift
long j = 0;.swift
for (double valueOf : dArr) {.swift
j += function1.invoke(Double.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final int sumOfUInt(short[] sArr, Function1<? super Short, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (short valueOf : sArr) {.swift
r1 = tr1.g(function1.invoke(Short.valueOf(valueOf)), r1);.swift
}.swift
return r1;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(long[] jArr, Function1<? super Long, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (long valueOf : jArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Long.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final List<Integer> takeLastWhile(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(iArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Integer.valueOf(iArr[lastIndex])).booleanValue()) {.swift
return drop(iArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(iArr);.swift
}.swift
public static final List<Integer> takeWhile(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Integer.valueOf(i));.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Double>> C toCollection(double[] dArr, C c) {.swift
for (double valueOf : dArr) {.swift
c.add(Double.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final List<Integer> toList(int[] iArr) {.swift
int length = iArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(iArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Integer.valueOf(iArr[0]));.swift
}.swift
public static final Set<Integer> toSet(int[] iArr) {.swift
int length = iArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(iArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(iArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Integer.valueOf(iArr[0]));.swift
}.swift
public static final Set<Double> union(double[] dArr, Iterable<Double> iterable) {.swift
Set<Double> mutableSet = toMutableSet(dArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final <R, V> List<V> zip(long[] jArr, R[] rArr, Function2<? super Long, ? super R, ? extends V> function2) {.swift
int min = Math.min(jArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Long.valueOf(jArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean any(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (long valueOf : jArr) {.swift
if (function1.invoke(Long.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Double, V> associateWith(double[] dArr, Function1<? super Double, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(dArr.length), 16));.swift
for (double d : dArr) {.swift
linkedHashMap.put(Double.valueOf(d), function1.invoke(Double.valueOf(d)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final int count(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
int i = 0;.swift
for (long valueOf : jArr) {.swift
if (function1.invoke(Long.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final Long firstOrNull(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
return Long.valueOf(j);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final <A extends Appendable> A joinTo(short[] sArr, A a, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Short, ? extends CharSequence> function1) {.swift
a.append(charSequence2);.swift
int i2 = 0;.swift
for (short s : sArr) {.swift
i2++;.swift
if (i2 > 1) {.swift
a.append(charSequence);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
break;.swift
}.swift
if (function1 = null) {.swift
a.append((CharSequence) function1.invoke(Short.valueOf(s)));.swift
} else {.swift
a.append(String.valueOf(s));.swift
}.swift
}.swift
if (i >= 0 && i2 > i) {.swift
a.append(charSequence4);.swift
}.swift
a.append(charSequence3);.swift
return a;.swift
}.swift
public static final boolean none(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (long valueOf : jArr) {.swift
if (function1.invoke(Long.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short randomOrNull(short[] sArr, Random random) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
return Short.valueOf(sArr[random.nextInt(sArr.length)]);.swift
}.swift
public static final void sortDescending(float[] fArr) {.swift
if (fArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(fArr);.swift
reverse(fArr);.swift
}.swift
}.swift
public static final List<Boolean> toMutableList(boolean[] zArr) {.swift
ArrayList arrayList = new ArrayList(zArr.length);.swift
for (boolean valueOf : zArr) {.swift
arrayList.add(Boolean.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean any(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (float valueOf : fArr) {.swift
if (function1.invoke(Float.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
public static final Iterable<Boolean> asIterable(boolean[] zArr) {.swift
if (zArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$8(zArr);.swift
}.swift
public static final Sequence<Boolean> asSequence(boolean[] zArr) {.swift
if (zArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$8(zArr);.swift
}.swift
public static final <K, M extends Map<? super K, ? super Boolean>> M associateByTo(boolean[] zArr, M m, Function1<? super Boolean, ? extends K> function1) {.swift
for (boolean z : zArr) {.swift
m.put(function1.invoke(Boolean.valueOf(z)), Boolean.valueOf(z));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(boolean[] zArr, M m, Function1<? super Boolean, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (boolean valueOf : zArr) {.swift
Pair pair = (Pair) function1.invoke(Boolean.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Boolean, ? super V>> M associateWithTo(boolean[] zArr, M m, Function1<? super Boolean, ? extends V> function1) {.swift
for (boolean z : zArr) {.swift
m.put(Boolean.valueOf(z), function1.invoke(Boolean.valueOf(z)));.swift
}.swift
return m;.swift
}.swift
public static final int count(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
int i = 0;.swift
for (float valueOf : fArr) {.swift
if (function1.invoke(Float.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final List<Boolean> filter(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
arrayList.add(Boolean.valueOf(z));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Boolean>> C filterIndexedTo(boolean[] zArr, C c, Function2<? super Integer, ? super Boolean, Boolean> function2) {.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
boolean z = zArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Boolean.valueOf(z)).booleanValue()) {.swift
c.add(Boolean.valueOf(z));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Boolean> filterNot(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
arrayList.add(Boolean.valueOf(z));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final Float firstOrNull(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
return Float.valueOf(f);.swift
}.swift
}.swift
return null;.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Boolean, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(boolean[] r2, R r3, kotlin.jvm.functions.Function2<? super java.lang.Boolean, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((boolean[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
boolean r0 = r2[r0].swift
java.lang.Boolean r0 = java.lang.Boolean.valueOf(r0).swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(boolean[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Boolean, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(boolean[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Boolean, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((boolean[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
boolean r2 = r3[r0].swift
java.lang.Boolean r2 = java.lang.Boolean.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(boolean[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
@Deprecated(message = "The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.", replaceWith = @ReplaceWith(expression = "indexOfFirst { it == element }", imports = {})).swift
@DeprecatedSinceKotlin(errorSince = "1.6", hiddenSince = "1.7", warningSince = "1.4").swift
public static final /* synthetic */ int indexOf(double[] dArr, double d) {.swift
int length = dArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (d == dArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
int length = zArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Boolean.valueOf(zArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
int length = zArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Boolean.valueOf(zArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Boolean> intersect(boolean[] zArr, Iterable<Boolean> iterable) {.swift
Set<Boolean> mutableSet = toMutableSet(zArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.", replaceWith = @ReplaceWith(expression = "indexOfLast { it == element }", imports = {})).swift
@DeprecatedSinceKotlin(errorSince = "1.6", hiddenSince = "1.7", warningSince = "1.4").swift
public static final /* synthetic */ int lastIndexOf(double[] dArr, double d) {.swift
int length = dArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (d == dArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(boolean[] zArr, C c, Function2<? super Integer, ? super Boolean, ? extends R> function2) {.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Boolean.valueOf(zArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(boolean[] zArr, C c, Function1<? super Boolean, ? extends R> function1) {.swift
for (boolean valueOf : zArr) {.swift
c.add(function1.invoke(Boolean.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final boolean none(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (float valueOf : fArr) {.swift
if (function1.invoke(Float.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final Pair<List<Short>, List<Short>> partition(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
ArrayList arrayList2 = new ArrayList();.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
arrayList.add(Short.valueOf(s));.swift
} else {.swift
arrayList2.add(Short.valueOf(s));.swift
}.swift
}.swift
return new Pair<>(arrayList, arrayList2);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer reduceIndexedOrNull(int[] iArr, Function3<? super Integer, ? super Integer, ? super Integer, Integer> function3) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
i = function3.invoke(Integer.valueOf(i2), Integer.valueOf(i), Integer.valueOf(iArr[i2])).intValue();.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer reduceOrNull(int[] iArr, Function2<? super Integer, ? super Integer, Integer> function2) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
i = function2.invoke(Integer.valueOf(i), Integer.valueOf(iArr[i2])).intValue();.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(byte[] bArr, Random random) {.swift
for (int lastIndex = getLastIndex(bArr); lastIndex > 0; lastIndex--) {.swift
int nextInt = random.nextInt(lastIndex + 1);.swift
byte b = bArr[lastIndex];.swift
bArr[lastIndex] = bArr[nextInt];.swift
bArr[nextInt] = b;.swift
}.swift
}.swift
public static final Short singleOrNull(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
Short sh = null;.swift
boolean z = false;.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
sh = Short.valueOf(s);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return sh;.swift
}.swift
public static final char[] sortedArray(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return cArr;.swift
}.swift
char[] copyOf = Arrays.copyOf(cArr, cArr.length);.swift
ArraysKt___ArraysJvmKt.sort(copyOf);.swift
return copyOf;.swift
}.swift
public static final char[] sortedArrayDescending(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return cArr;.swift
}.swift
char[] copyOf = Arrays.copyOf(cArr, cArr.length);.swift
sortDescending(copyOf);.swift
return copyOf;.swift
}.swift
public static final Set<Boolean> subtract(boolean[] zArr, Iterable<Boolean> iterable) {.swift
Set<Boolean> mutableSet = toMutableSet(zArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(boolean[] zArr, Function1<? super Boolean, Integer> function1) {.swift
int i = 0;.swift
for (boolean valueOf : zArr) {.swift
i += function1.invoke(Boolean.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(boolean[] zArr, Function1<? super Boolean, Double> function1) {.swift
double d = 0.0d;.swift
for (boolean valueOf : zArr) {.swift
d += function1.invoke(Boolean.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(boolean[] zArr, Function1<? super Boolean, Double> function1) {.swift
double d = 0.0d;.swift
for (boolean valueOf : zArr) {.swift
d += function1.invoke(Boolean.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(boolean[] zArr, Function1<? super Boolean, Integer> function1) {.swift
int i = 0;.swift
for (boolean valueOf : zArr) {.swift
i += function1.invoke(Boolean.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(boolean[] zArr, Function1<? super Boolean, Long> function1) {.swift
long j = 0;.swift
for (boolean valueOf : zArr) {.swift
j += function1.invoke(Boolean.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
public static final List<Byte> take(byte[] bArr, int i) {.swift
if (i < 0) {.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
} else if (i == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
} else {.swift
if (i >= bArr.length) {.swift
return toList(bArr);.swift
}.swift
if (i == 1) {.swift
return CollectionsKt__CollectionsJVMKt.listOf(Byte.valueOf(bArr[0]));.swift
}.swift
ArrayList arrayList = new ArrayList(i);.swift
int i2 = 0;.swift
for (byte valueOf : bArr) {.swift
arrayList.add(Byte.valueOf(valueOf));.swift
i2++;.swift
if (i2 == i) {.swift
break;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
}.swift
public static final List<Byte> takeLast(byte[] bArr, int i) {.swift
if (i < 0) {.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
} else if (i == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
} else {.swift
int length = bArr.length;.swift
if (i >= length) {.swift
return toList(bArr);.swift
}.swift
if (i == 1) {.swift
return CollectionsKt__CollectionsJVMKt.listOf(Byte.valueOf(bArr[length - 1]));.swift
}.swift
ArrayList arrayList = new ArrayList(i);.swift
for (int i2 = length - i; i2 < length; i2++) {.swift
arrayList.add(Byte.valueOf(bArr[i2]));.swift
}.swift
return arrayList;.swift
}.swift
}.swift
public static final <C extends Collection<? super Boolean>> C toCollection(boolean[] zArr, C c) {.swift
for (boolean valueOf : zArr) {.swift
c.add(Boolean.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static final Set<Boolean> union(boolean[] zArr, Iterable<Boolean> iterable) {.swift
Set<Boolean> mutableSet = toMutableSet(zArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final boolean any(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (double valueOf : dArr) {.swift
if (function1.invoke(Double.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Boolean, V> associateWith(boolean[] zArr, Function1<? super Boolean, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(zArr.length), 16));.swift
for (boolean z : zArr) {.swift
linkedHashMap.put(Boolean.valueOf(z), function1.invoke(Boolean.valueOf(z)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final int count(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
int i = 0;.swift
for (double valueOf : dArr) {.swift
if (function1.invoke(Double.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final List<Integer> dropWhile(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (int i : iArr) {.swift
if (z) {.swift
arrayList.add(Integer.valueOf(i));.swift
} else if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
arrayList.add(Integer.valueOf(i));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Float> filterIndexed(float[] fArr, Function2<? super Integer, ? super Float, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
float f = fArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Float.valueOf(f)).booleanValue()) {.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final Float findLast(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
int length = fArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
float f = fArr[length];.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
return Float.valueOf(f);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static float first(float[] fArr) {.swift
if (fArr.length = 0) {.swift
return fArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Double firstOrNull(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
return Double.valueOf(d);.swift
}.swift
}.swift
return null;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(float[] fArr, C c, Function2<? super Integer, ? super Float, ? extends Iterable<? extends R>> function2) {.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Float.valueOf(fArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(float[] fArr, C c, Function1<? super Float, ? extends Iterable<? extends R>> function1) {.swift
for (float valueOf : fArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Float.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final float last(float[] fArr) {.swift
if (fArr.length = 0) {.swift
return fArr[getLastIndex(fArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Short lastOrNull(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
int length = sArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
short s = sArr[length];.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
return Short.valueOf(s);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
public static final <R> List<R> map(float[] fArr, Function1<? super Float, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(fArr.length);.swift
for (float valueOf : fArr) {.swift
arrayList.add(function1.invoke(Float.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(float[] fArr, Function2<? super Integer, ? super Float, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(fArr.length);.swift
int length = fArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Float.valueOf(fArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(int[] iArr, Comparator<? super R> comparator, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Integer.valueOf(iArr[0]));.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Integer.valueOf(iArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(int[] iArr, Comparator<? super R> comparator, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Integer.valueOf(iArr[0]));.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Integer.valueOf(iArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
public static final boolean none(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (double valueOf : dArr) {.swift
if (function1.invoke(Double.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final short random(short[] sArr, Random random) {.swift
if (sArr.length = 0) {.swift
return sArr[random.nextInt(sArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer randomOrNull(int[] iArr, Random random) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
return Integer.valueOf(iArr[random.nextInt(iArr.length)]);.swift
}.swift
public static final int reduce(int[] iArr, Function2<? super Integer, ? super Integer, Integer> function2) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
i = function2.invoke(Integer.valueOf(i), Integer.valueOf(iArr[i2])).intValue();.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final int reduceIndexed(int[] iArr, Function3<? super Integer, ? super Integer, ? super Integer, Integer> function3) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
i = function3.invoke(Integer.valueOf(i2), Integer.valueOf(i), Integer.valueOf(iArr[i2])).intValue();.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long reduceRightIndexedOrNull(long[] jArr, Function3<? super Integer, ? super Long, ? super Long, Long> function3) {.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
long j = jArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
j = function3.invoke(Integer.valueOf(i), Long.valueOf(jArr[i]), Long.valueOf(j)).longValue();.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long reduceRightOrNull(long[] jArr, Function2<? super Long, ? super Long, Long> function2) {.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
long j = jArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
j = function2.invoke(Long.valueOf(jArr[i]), Long.valueOf(j)).longValue();.swift
}.swift
return Long.valueOf(j);.swift
}.swift
public static void reverse(int[] iArr) {.swift
int length = (iArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(iArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
int i2 = iArr[i];.swift
iArr[i] = iArr[lastIndex];.swift
iArr[lastIndex] = i2;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
public static final List<Float> reversed(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Float> mutableList = toMutableList(fArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Integer, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(int[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Integer, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
return r4.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r4[r2].swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(int[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Integer, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(int[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Integer, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Integer r4 = java.lang.Integer.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(int[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
public static final float[] sliceArray(float[] fArr, Collection<Integer> collection) {.swift
float[] fArr2 = new float[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
fArr2[i] = fArr[intValue.intValue()];.swift
i++;.swift
}.swift
return fArr2;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(float[] fArr, Function1<? super Float, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (float valueOf : fArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Float.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final List<Character> toMutableList(char[] cArr) {.swift
ArrayList arrayList = new ArrayList(cArr.length);.swift
for (char valueOf : cArr) {.swift
arrayList.add(Character.valueOf(valueOf));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R, V> List<V> zip(float[] fArr, R[] rArr, Function2<? super Float, ? super R, ? extends V> function2) {.swift
int min = Math.min(fArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Float.valueOf(fArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final boolean any(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean valueOf : zArr) {.swift
if (function1.invoke(Boolean.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
public static final Iterable<Character> asIterable(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return new ArraysKt___ArraysKt$asIterable$$inlined$Iterable$9(cArr);.swift
}.swift
public static final Sequence<Character> asSequence(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return SequencesKt.emptySequence();.swift
}.swift
return new ArraysKt___ArraysKt$asSequence$$inlined$Sequence$9(cArr);.swift
}.swift
public static final <K, V> Map<K, V> associate(long[] jArr, Function1<? super Long, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(jArr.length), 16));.swift
for (long valueOf : jArr) {.swift
Pair pair = (Pair) function1.invoke(Long.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Long> associateBy(long[] jArr, Function1<? super Long, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(jArr.length), 16));.swift
for (long j : jArr) {.swift
linkedHashMap.put(function1.invoke(Long.valueOf(j)), Long.valueOf(j));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, M extends Map<? super K, ? super Character>> M associateByTo(char[] cArr, M m, Function1<? super Character, ? extends K> function1) {.swift
for (char c : cArr) {.swift
m.put(function1.invoke(Character.valueOf(c)), Character.valueOf(c));.swift
}.swift
return m;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateTo(char[] cArr, M m, Function1<? super Character, ? extends Pair<? extends K, ? extends V>> function1) {.swift
for (char valueOf : cArr) {.swift
Pair pair = (Pair) function1.invoke(Character.valueOf(valueOf));.swift
m.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V, M extends Map<? super Character, ? super V>> M associateWithTo(char[] cArr, M m, Function1<? super Character, ? extends V> function1) {.swift
for (char c : cArr) {.swift
m.put(Character.valueOf(c), function1.invoke(Character.valueOf(c)));.swift
}.swift
return m;.swift
}.swift
public static final int count(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
int i = 0;.swift
for (boolean valueOf : zArr) {.swift
if (function1.invoke(Boolean.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final List<Long> dropLastWhile(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(jArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Long.valueOf(jArr[lastIndex])).booleanValue()) {.swift
return take(jArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final List<Character> filter(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (char c : cArr) {.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
arrayList.add(Character.valueOf(c));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Character>> C filterIndexedTo(char[] cArr, C c, Function2<? super Integer, ? super Character, Boolean> function2) {.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
char c2 = cArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Character.valueOf(c2)).booleanValue()) {.swift
c.add(Character.valueOf(c2));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return c;.swift
}.swift
public static final List<Character> filterNot(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (char c : cArr) {.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
arrayList.add(Character.valueOf(c));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final Boolean firstOrNull(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
return Boolean.valueOf(z);.swift
}.swift
}.swift
return null;.swift
}.swift
public static final <R> List<R> flatMap(long[] jArr, Function1<? super Long, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (long valueOf : jArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Long.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
/* JADX WARNING: type inference failed for: r4v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super java.lang.Character, ? super R, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRight(char[] r2, R r3, kotlin.jvm.functions.Function2<? super java.lang.Character, ? super R, ? extends R> r4) {.swift
/*.swift
int r0 = getLastIndex((char[]) r2).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0014.swift
int r1 = r0 + -1.swift
char r0 = r2[r0].swift
java.lang.Character r0 = java.lang.Character.valueOf(r0).swift
java.lang.Object r3 = r4.invoke(r0, r3).swift
r0 = r1.swift
goto L_0x0004.swift
L_0x0014:.swift
return r3.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRight(char[], java.lang.Object, kotlin.jvm.functions.Function2):java.lang.Object");.swift
}.swift
/* JADX WARNING: type inference failed for: r5v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Character, ? super R, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
public static final <R> R foldRightIndexed(char[] r3, R r4, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super java.lang.Character, ? super R, ? extends R> r5) {.swift
/*.swift
int r0 = getLastIndex((char[]) r3).swift
L_0x0004:.swift
if (r0 < 0) goto L_0x0017.swift
java.lang.Integer r1 = java.lang.Integer.valueOf(r0).swift
char r2 = r3[r0].swift
java.lang.Character r2 = java.lang.Character.valueOf(r2).swift
java.lang.Object r4 = r5.invoke(r1, r2, r4).swift
int r0 = r0 + -1.swift
goto L_0x0004.swift
L_0x0017:.swift
return r4.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.foldRightIndexed(char[], java.lang.Object, kotlin.jvm.functions.Function3):java.lang.Object");.swift
}.swift
public static final int indexOf(boolean[] zArr, boolean z) {.swift
int length = zArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (z == zArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfFirst(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
int length = cArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (function1.invoke(Character.valueOf(cArr[i])).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final int indexOfLast(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
int length = cArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (function1.invoke(Character.valueOf(cArr[length])).booleanValue()) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Set<Character> intersect(char[] cArr, Iterable<Character> iterable) {.swift
Set<Character> mutableSet = toMutableSet(cArr);.swift
CollectionsKt__MutableCollectionsKt.retainAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final int lastIndexOf(boolean[] zArr, boolean z) {.swift
int length = zArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (z == zArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapIndexedTo(char[] cArr, C c, Function2<? super Integer, ? super Character, ? extends R> function2) {.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
c.add(function2.invoke(Integer.valueOf(i2), Character.valueOf(cArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C mapTo(char[] cArr, C c, Function1<? super Character, ? extends R> function1) {.swift
for (char valueOf : cArr) {.swift
c.add(function1.invoke(Character.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Short maxByOrNull(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex == 0) {.swift
return Short.valueOf(s);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Short.valueOf(s));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Short.valueOf(s2));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
s = s2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxByOrThrow").swift
public static final <R extends Comparable<? super R>> short maxByOrThrow(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex == 0) {.swift
return s;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Short.valueOf(s));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Short.valueOf(s2));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
s = s2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Short minByOrNull(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex == 0) {.swift
return Short.valueOf(s);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Short.valueOf(s));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Short.valueOf(s2));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
s = s2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minByOrThrow").swift
public static final <R extends Comparable<? super R>> short minByOrThrow(short[] sArr, Function1<? super Short, ? extends R> function1) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
if (lastIndex == 0) {.swift
return s;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Short.valueOf(s));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Short.valueOf(s2));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
s = s2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
public static final boolean none(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (boolean valueOf : zArr) {.swift
if (function1.invoke(Boolean.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
public static final long reduceRight(long[] jArr, Function2<? super Long, ? super Long, Long> function2) {.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex >= 0) {.swift
long j = jArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
j = function2.invoke(Long.valueOf(jArr[i]), Long.valueOf(j)).longValue();.swift
}.swift
return j;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final long reduceRightIndexed(long[] jArr, Function3<? super Integer, ? super Long, ? super Long, Long> function3) {.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex >= 0) {.swift
long j = jArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
j = function3.invoke(Integer.valueOf(i), Long.valueOf(jArr[i]), Long.valueOf(j)).longValue();.swift
}.swift
return j;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static long[] reversedArray(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return jArr;.swift
}.swift
long[] jArr2 = new long[jArr.length];.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
jArr2[lastIndex - i] = jArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return jArr2;.swift
}.swift
public static long single(long[] jArr) {.swift
int length = jArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return jArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final void sortDescending(double[] dArr) {.swift
if (dArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(dArr);.swift
reverse(dArr);.swift
}.swift
}.swift
public static final Set<Character> subtract(char[] cArr, Iterable<Character> iterable) {.swift
Set<Character> mutableSet = toMutableSet(cArr);.swift
CollectionsKt__MutableCollectionsKt.removeAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final int sumBy(char[] cArr, Function1<? super Character, Integer> function1) {.swift
int i = 0;.swift
for (char valueOf : cArr) {.swift
i += function1.invoke(Character.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@Deprecated(message = "Use sumOf instead.", replaceWith = @ReplaceWith(expression = "this.sumOf(selector)", imports = {})).swift
@DeprecatedSinceKotlin(warningSince = "1.5").swift
public static final double sumByDouble(char[] cArr, Function1<? super Character, Double> function1) {.swift
double d = 0.0d;.swift
for (char valueOf : cArr) {.swift
d += function1.invoke(Character.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfDouble").swift
private static final double sumOfDouble(char[] cArr, Function1<? super Character, Double> function1) {.swift
double d = 0.0d;.swift
for (char valueOf : cArr) {.swift
d += function1.invoke(Character.valueOf(valueOf)).doubleValue();.swift
}.swift
return d;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfInt").swift
private static final int sumOfInt(char[] cArr, Function1<? super Character, Integer> function1) {.swift
int i = 0;.swift
for (char valueOf : cArr) {.swift
i += function1.invoke(Character.valueOf(valueOf)).intValue();.swift
}.swift
return i;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "sumOfLong").swift
private static final long sumOfLong(char[] cArr, Function1<? super Character, Long> function1) {.swift
long j = 0;.swift
for (char valueOf : cArr) {.swift
j += function1.invoke(Character.valueOf(valueOf)).longValue();.swift
}.swift
return j;.swift
}.swift
public static final List<Long> takeLastWhile(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(jArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Long.valueOf(jArr[lastIndex])).booleanValue()) {.swift
return drop(jArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(jArr);.swift
}.swift
public static final List<Long> takeWhile(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
return arrayList;.swift
}.swift
public static final <C extends Collection<? super Character>> C toCollection(char[] cArr, C c) {.swift
for (char valueOf : cArr) {.swift
c.add(Character.valueOf(valueOf));.swift
}.swift
return c;.swift
}.swift
public static List<Long> toList(long[] jArr) {.swift
int length = jArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(jArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Long.valueOf(jArr[0]));.swift
}.swift
public static Set<Long> toSet(long[] jArr) {.swift
int length = jArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(jArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(jArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Long.valueOf(jArr[0]));.swift
}.swift
public static final Set<Character> union(char[] cArr, Iterable<Character> iterable) {.swift
Set<Character> mutableSet = toMutableSet(cArr);.swift
CollectionsKt__MutableCollectionsKt.addAll(mutableSet, iterable);.swift
return mutableSet;.swift
}.swift
public static final boolean any(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (char valueOf : cArr) {.swift
if (function1.invoke(Character.valueOf(valueOf)).booleanValue()) {.swift
return true;.swift
}.swift
}.swift
return false;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <V> Map<Character, V> associateWith(char[] cArr, Function1<? super Character, ? extends V> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(RangesKt.coerceAtMost(cArr.length, (int) Uuid.SIZE_BITS)), 16));.swift
for (char c : cArr) {.swift
linkedHashMap.put(Character.valueOf(c), function1.invoke(Character.valueOf(c)));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final int count(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
int i = 0;.swift
for (char valueOf : cArr) {.swift
if (function1.invoke(Character.valueOf(valueOf)).booleanValue()) {.swift
i++;.swift
}.swift
}.swift
return i;.swift
}.swift
public static final Character firstOrNull(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (char c : cArr) {.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
return Character.valueOf(c);.swift
}.swift
}.swift
return null;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte maxOrNull(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (b < b2) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer maxWithOrNull(int[] iArr, Comparator<? super Integer> comparator) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (comparator.compare(Integer.valueOf(i), Integer.valueOf(i3)) < 0) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Byte minOrNull(byte[] bArr) {.swift
if (bArr.length == 0) {.swift
return null;.swift
}.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (b > b2) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Byte.valueOf(b);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer minWithOrNull(int[] iArr, Comparator<? super Integer> comparator) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (comparator.compare(Integer.valueOf(i), Integer.valueOf(i3)) > 0) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
public static final boolean none(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (char valueOf : cArr) {.swift
if (function1.invoke(Character.valueOf(valueOf)).booleanValue()) {.swift
return false;.swift
}.swift
}.swift
return true;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long randomOrNull(long[] jArr, Random random) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
return Long.valueOf(jArr[random.nextInt(jArr.length)]);.swift
}.swift
public static final Integer singleOrNull(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
Integer num = null;.swift
boolean z = false;.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
num = Integer.valueOf(i);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return num;.swift
}.swift
public static final <T, K, V, M extends Map<? super K, ? super V>> M associateByTo(T[] tArr, M m, Function1<? super T, ? extends K> function1, Function1<? super T, ? extends V> function12) {.swift
for (T t : tArr) {.swift
m.put(function1.invoke(t), function12.invoke(t));.swift
}.swift
return m;.swift
}.swift
public static final <K> List<Integer> distinctBy(int[] iArr, Function1<? super Integer, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (int i : iArr) {.swift
if (hashSet.add(function1.invoke(Integer.valueOf(i)))) {.swift
arrayList.add(Integer.valueOf(i));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Short> drop(short[] sArr, int i) {.swift
if (i >= 0) {.swift
return takeLast(sArr, RangesKt.coerceAtLeast(sArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final List<Short> dropLast(short[] sArr, int i) {.swift
if (i >= 0) {.swift
return take(sArr, RangesKt.coerceAtLeast(sArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final List<Double> filterIndexed(double[] dArr, Function2<? super Integer, ? super Double, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
double d = dArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Double.valueOf(d)).booleanValue()) {.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final Double findLast(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
int length = dArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
double d = dArr[length];.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
return Double.valueOf(d);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static final double first(double[] dArr) {.swift
if (dArr.length = 0) {.swift
return dArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(double[] dArr, C c, Function2<? super Integer, ? super Double, ? extends Iterable<? extends R>> function2) {.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Double.valueOf(dArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(double[] dArr, C c, Function1<? super Double, ? extends Iterable<? extends R>> function1) {.swift
for (double valueOf : dArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Double.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final <K, M extends Map<? super K, List<Short>>> M groupByTo(short[] sArr, M m, Function1<? super Short, ? extends K> function1) {.swift
for (short s : sArr) {.swift
Object invoke = function1.invoke(Short.valueOf(s));.swift
Object obj = m.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.r(m, invoke);.swift
}.swift
((List) obj).add(Short.valueOf(s));.swift
}.swift
return m;.swift
}.swift
public static final int indexOf(char[] cArr, char c) {.swift
int length = cArr.length;.swift
for (int i = 0; i < length; i++) {.swift
if (c == cArr[i]) {.swift
return i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final double last(double[] dArr) {.swift
if (dArr.length = 0) {.swift
return dArr[getLastIndex(dArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final int lastIndexOf(char[] cArr, char c) {.swift
int length = cArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
if (c == cArr[length]) {.swift
return length;.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return -1;.swift
}.swift
public static final Integer lastOrNull(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
int length = iArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
int i2 = iArr[length];.swift
if (function1.invoke(Integer.valueOf(i2)).booleanValue()) {.swift
return Integer.valueOf(i2);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
public static final <R> List<R> map(double[] dArr, Function1<? super Double, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(dArr.length);.swift
for (double valueOf : dArr) {.swift
arrayList.add(function1.invoke(Double.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(double[] dArr, Function2<? super Integer, ? super Double, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(dArr.length);.swift
int length = dArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Double.valueOf(dArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double maxOf(int[] iArr, Function1<? super Integer, Double> function1) {.swift
if (iArr.length = 0) {.swift
double doubleValue = function1.invoke(Integer.valueOf(iArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Integer.valueOf(iArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final Double m400maxOfOrNull(int[] iArr, Function1<? super Integer, Double> function1) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Integer.valueOf(iArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Integer.valueOf(iArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWith(int[] iArr, Comparator<? super R> comparator, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length = 0) {.swift
R invoke = function1.invoke(Integer.valueOf(iArr[0]));.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Integer.valueOf(iArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final byte maxOrThrow(byte[] bArr) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (b < b2) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final int maxWithOrThrow(int[] iArr, Comparator<? super Integer> comparator) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (comparator.compare(Integer.valueOf(i), Integer.valueOf(i3)) < 0) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double minOf(int[] iArr, Function1<? super Integer, Double> function1) {.swift
if (iArr.length = 0) {.swift
double doubleValue = function1.invoke(Integer.valueOf(iArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Integer.valueOf(iArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final Double m436minOfOrNull(int[] iArr, Function1<? super Integer, Double> function1) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Integer.valueOf(iArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Integer.valueOf(iArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWith(int[] iArr, Comparator<? super R> comparator, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length = 0) {.swift
R invoke = function1.invoke(Integer.valueOf(iArr[0]));.swift
int lastIndex = getLastIndex(iArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Integer.valueOf(iArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final byte minOrThrow(byte[] bArr) {.swift
if (bArr.length = 0) {.swift
byte b = bArr[0];.swift
int lastIndex = getLastIndex(bArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
byte b2 = bArr[i];.swift
if (b > b2) {.swift
b = b2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return b;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final int minWithOrThrow(int[] iArr, Comparator<? super Integer> comparator) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (comparator.compare(Integer.valueOf(i), Integer.valueOf(i3)) > 0) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final int random(int[] iArr, Random random) {.swift
if (iArr.length = 0) {.swift
return iArr[random.nextInt(iArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final List<Double> reversed(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Double> mutableList = toMutableList(dArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Integer> runningReduce(int[] iArr, Function2<? super Integer, ? super Integer, Integer> function2) {.swift
if (iArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
int i = iArr[0];.swift
ArrayList arrayList = new ArrayList(iArr.length);.swift
arrayList.add(Integer.valueOf(i));.swift
int length = iArr.length;.swift
for (int i2 = 1; i2 < length; i2++) {.swift
i = function2.invoke(Integer.valueOf(i), Integer.valueOf(iArr[i2])).intValue();.swift
arrayList.add(Integer.valueOf(i));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Integer> runningReduceIndexed(int[] iArr, Function3<? super Integer, ? super Integer, ? super Integer, Integer> function3) {.swift
if (iArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
int i = iArr[0];.swift
ArrayList arrayList = new ArrayList(iArr.length);.swift
arrayList.add(Integer.valueOf(i));.swift
int length = iArr.length;.swift
for (int i2 = 1; i2 < length; i2++) {.swift
i = function3.invoke(Integer.valueOf(i2), Integer.valueOf(i), Integer.valueOf(iArr[i2])).intValue();.swift
arrayList.add(Integer.valueOf(i));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Integer> slice(int[] iArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList(ArraysKt___ArraysJvmKt.copyOfRange(iArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
public static final double[] sliceArray(double[] dArr, Collection<Integer> collection) {.swift
double[] dArr2 = new double[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
dArr2[i] = dArr[intValue.intValue()];.swift
i++;.swift
}.swift
return dArr2;.swift
}.swift
@JvmName(name = "sumOfDouble").swift
public static final double sumOfDouble(Double[] dArr) {.swift
double d = 0.0d;.swift
for (Double doubleValue : dArr) {.swift
d += doubleValue.doubleValue();.swift
}.swift
return d;.swift
}.swift
@JvmName(name = "sumOfInt").swift
public static final int sumOfInt(Integer[] numArr) {.swift
int i = 0;.swift
for (Integer intValue : numArr) {.swift
i += intValue.intValue();.swift
}.swift
return i;.swift
}.swift
@JvmName(name = "sumOfLong").swift
public static final long sumOfLong(Long[] lArr) {.swift
long j = 0;.swift
for (Long longValue : lArr) {.swift
j += longValue.longValue();.swift
}.swift
return j;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final int sumOfUInt(int[] iArr, Function1<? super Integer, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (int valueOf : iArr) {.swift
r1 = tr1.g(function1.invoke(Integer.valueOf(valueOf)), r1);.swift
}.swift
return r1;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(double[] dArr, Function1<? super Double, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (double valueOf : dArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Double.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final <R, V> List<V> zip(double[] dArr, R[] rArr, Function2<? super Double, ? super R, ? extends V> function2) {.swift
int min = Math.min(dArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Double.valueOf(dArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float randomOrNull(float[] fArr, Random random) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
return Float.valueOf(fArr[random.nextInt(fArr.length)]);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long reduceIndexedOrNull(long[] jArr, Function3<? super Integer, ? super Long, ? super Long, Long> function3) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
j = function3.invoke(Integer.valueOf(i), Long.valueOf(j), Long.valueOf(jArr[i])).longValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long reduceOrNull(long[] jArr, Function2<? super Long, ? super Long, Long> function2) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
j = function2.invoke(Long.valueOf(j), Long.valueOf(jArr[i])).longValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float reduceRightIndexedOrNull(float[] fArr, Function3<? super Integer, ? super Float, ? super Float, Float> function3) {.swift
int lastIndex = getLastIndex(fArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
float f = fArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
f = function3.invoke(Integer.valueOf(i), Float.valueOf(fArr[i]), Float.valueOf(f)).floatValue();.swift
}.swift
return Float.valueOf(f);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float reduceRightOrNull(float[] fArr, Function2<? super Float, ? super Float, Float> function2) {.swift
int lastIndex = getLastIndex(fArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
float f = fArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
f = function2.invoke(Float.valueOf(fArr[i]), Float.valueOf(f)).floatValue();.swift
}.swift
return Float.valueOf(f);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(short[] sArr, Random random) {.swift
for (int lastIndex = getLastIndex(sArr); lastIndex > 0; lastIndex--) {.swift
int nextInt = random.nextInt(lastIndex + 1);.swift
short s = sArr[lastIndex];.swift
sArr[lastIndex] = sArr[nextInt];.swift
sArr[nextInt] = s;.swift
}.swift
}.swift
public static final void sortDescending(char[] cArr) {.swift
if (cArr.length > 1) {.swift
ArraysKt___ArraysJvmKt.sort(cArr);.swift
reverse(cArr);.swift
}.swift
}.swift
public static final <K, V> Map<K, V> associate(float[] fArr, Function1<? super Float, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(fArr.length), 16));.swift
for (float valueOf : fArr) {.swift
Pair pair = (Pair) function1.invoke(Float.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Float> associateBy(float[] fArr, Function1<? super Float, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(fArr.length), 16));.swift
for (float f : fArr) {.swift
linkedHashMap.put(function1.invoke(Float.valueOf(f)), Float.valueOf(f));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(byte[] bArr, M m, Function1<? super Byte, ? extends K> function1, Function1<? super Byte, ? extends V> function12) {.swift
for (byte b : bArr) {.swift
m.put(function1.invoke(Byte.valueOf(b)), function12.invoke(Byte.valueOf(b)));.swift
}.swift
return m;.swift
}.swift
public static final List<Float> dropLastWhile(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(fArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Float.valueOf(fArr[lastIndex])).booleanValue()) {.swift
return take(fArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final List<Long> dropWhile(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (long j : jArr) {.swift
if (z) {.swift
arrayList.add(Long.valueOf(j));.swift
} else if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
arrayList.add(Long.valueOf(j));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> flatMap(float[] fArr, Function1<? super Float, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (float valueOf : fArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Float.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <K> Map<K, List<Short>> groupBy(short[] sArr, Function1<? super Short, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap();.swift
for (short s : sArr) {.swift
Object invoke = function1.invoke(Short.valueOf(s));.swift
Object obj = linkedHashMap.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.q(linkedHashMap, invoke);.swift
}.swift
((List) obj).add(Short.valueOf(s));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <A extends Appendable> A joinTo(int[] iArr, A a, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Integer, ? extends CharSequence> function1) {.swift
a.append(charSequence2);.swift
int i2 = 0;.swift
for (int i3 : iArr) {.swift
i2++;.swift
if (i2 > 1) {.swift
a.append(charSequence);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
break;.swift
}.swift
if (function1 = null) {.swift
a.append((CharSequence) function1.invoke(Integer.valueOf(i3)));.swift
} else {.swift
a.append(String.valueOf(i3));.swift
}.swift
}.swift
if (i >= 0 && i2 > i) {.swift
a.append(charSequence4);.swift
}.swift
a.append(charSequence3);.swift
return a;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(long[] jArr, Comparator<? super R> comparator, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Long.valueOf(jArr[0]));.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Long.valueOf(jArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(long[] jArr, Comparator<? super R> comparator, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Long.valueOf(jArr[0]));.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Long.valueOf(jArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
public static final long reduce(long[] jArr, Function2<? super Long, ? super Long, Long> function2) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
j = function2.invoke(Long.valueOf(j), Long.valueOf(jArr[i])).longValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final long reduceIndexed(long[] jArr, Function3<? super Integer, ? super Long, ? super Long, Long> function3) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
j = function3.invoke(Integer.valueOf(i), Long.valueOf(j), Long.valueOf(jArr[i])).longValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final float reduceRight(float[] fArr, Function2<? super Float, ? super Float, Float> function2) {.swift
int lastIndex = getLastIndex(fArr);.swift
if (lastIndex >= 0) {.swift
float f = fArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
f = function2.invoke(Float.valueOf(fArr[i]), Float.valueOf(f)).floatValue();.swift
}.swift
return f;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final float reduceRightIndexed(float[] fArr, Function3<? super Integer, ? super Float, ? super Float, Float> function3) {.swift
int lastIndex = getLastIndex(fArr);.swift
if (lastIndex >= 0) {.swift
float f = fArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
f = function3.invoke(Integer.valueOf(i), Float.valueOf(fArr[i]), Float.valueOf(f)).floatValue();.swift
}.swift
return f;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static void reverse(long[] jArr) {.swift
int length = (jArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(jArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
long j = jArr[i];.swift
jArr[i] = jArr[lastIndex];.swift
jArr[lastIndex] = j;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
public static final float[] reversedArray(float[] fArr) {.swift
if (fArr.length == 0) {.swift
return fArr;.swift
}.swift
float[] fArr2 = new float[fArr.length];.swift
int lastIndex = getLastIndex(fArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
fArr2[lastIndex - i] = fArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return fArr2;.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Long, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(long[] r5, R r6, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Long, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r5[r2].swift
java.lang.Long r3 = java.lang.Long.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r6, r3).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(long[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r8v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Long, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(long[] r6, R r7, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Long, ? extends R> r8) {.swift
/*.swift
int r0 = r6.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r6 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r7).swift
return r6.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r6.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r7).swift
int r1 = r6.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r6[r2].swift
java.lang.Long r4 = java.lang.Long.valueOf(r4).swift
java.lang.Object r7 = r8.invoke(r3, r7, r4).swift
r0.add(r7).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(long[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
public static final float single(float[] fArr) {.swift
int length = fArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return fArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final Long singleOrNull(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
Long l = null;.swift
boolean z = false;.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
l = Long.valueOf(j);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return l;.swift
}.swift
public static final List<Float> takeLastWhile(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(fArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Float.valueOf(fArr[lastIndex])).booleanValue()) {.swift
return drop(fArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(fArr);.swift
}.swift
public static final List<Float> takeWhile(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Float> toList(float[] fArr) {.swift
int length = fArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(fArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Float.valueOf(fArr[0]));.swift
}.swift
public static final Set<Float> toSet(float[] fArr) {.swift
int length = fArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(fArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(fArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Float.valueOf(fArr[0]));.swift
}.swift
public static final List<Boolean> filterIndexed(boolean[] zArr, Function2<? super Integer, ? super Boolean, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
boolean z = zArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Boolean.valueOf(z)).booleanValue()) {.swift
arrayList.add(Boolean.valueOf(z));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final Boolean findLast(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
int length = zArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
boolean z = zArr[length];.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
return Boolean.valueOf(z);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static final boolean first(boolean[] zArr) {.swift
if (zArr.length = 0) {.swift
return zArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(boolean[] zArr, C c, Function2<? super Integer, ? super Boolean, ? extends Iterable<? extends R>> function2) {.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Boolean.valueOf(zArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(boolean[] zArr, C c, Function1<? super Boolean, ? extends Iterable<? extends R>> function1) {.swift
for (boolean valueOf : zArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Boolean.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final boolean last(boolean[] zArr) {.swift
if (zArr.length = 0) {.swift
return zArr[getLastIndex(zArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Long lastOrNull(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
int length = jArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
long j = jArr[length];.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
return Long.valueOf(j);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
public static final <R> List<R> map(boolean[] zArr, Function1<? super Boolean, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(zArr.length);.swift
for (boolean valueOf : zArr) {.swift
arrayList.add(function1.invoke(Boolean.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(boolean[] zArr, Function2<? super Integer, ? super Boolean, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(zArr.length);.swift
int length = zArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Boolean.valueOf(zArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
public static final Pair<List<Integer>, List<Integer>> partition(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
ArrayList arrayList2 = new ArrayList();.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
arrayList.add(Integer.valueOf(i));.swift
} else {.swift
arrayList2.add(Integer.valueOf(i));.swift
}.swift
}.swift
return new Pair<>(arrayList, arrayList2);.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final long random(long[] jArr, Random random) {.swift
if (jArr.length = 0) {.swift
return jArr[random.nextInt(jArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double randomOrNull(double[] dArr, Random random) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
return Double.valueOf(dArr[random.nextInt(dArr.length)]);.swift
}.swift
public static final List<Boolean> reversed(boolean[] zArr) {.swift
if (zArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Boolean> mutableList = toMutableList(zArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
public static final boolean[] sliceArray(boolean[] zArr, Collection<Integer> collection) {.swift
boolean[] zArr2 = new boolean[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
zArr2[i] = zArr[intValue.intValue()];.swift
i++;.swift
}.swift
return zArr2;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(boolean[] zArr, Function1<? super Boolean, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (boolean valueOf : zArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Boolean.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final <R, V> List<V> zip(boolean[] zArr, R[] rArr, Function2<? super Boolean, ? super R, ? extends V> function2) {.swift
int min = Math.min(zArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Boolean.valueOf(zArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(short[] sArr, M m, Function1<? super Short, ? extends K> function1, Function1<? super Short, ? extends V> function12) {.swift
for (short s : sArr) {.swift
m.put(function1.invoke(Short.valueOf(s)), function12.invoke(Short.valueOf(s)));.swift
}.swift
return m;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short maxOrNull(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (s < s2) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Short minOrNull(short[] sArr) {.swift
if (sArr.length == 0) {.swift
return null;.swift
}.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (s > s2) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Short.valueOf(s);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <T extends Comparable<? super T>> void sortDescending(T[] tArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sortWith(tArr, ComparisonsKt.reverseOrder(), i, i2);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final short maxOrThrow(short[] sArr) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (s < s2) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long maxWithOrNull(long[] jArr, Comparator<? super Long> comparator) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (comparator.compare(Long.valueOf(j), Long.valueOf(j2)) < 0) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final short minOrThrow(short[] sArr) {.swift
if (sArr.length = 0) {.swift
short s = sArr[0];.swift
int lastIndex = getLastIndex(sArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
short s2 = sArr[i];.swift
if (s > s2) {.swift
s = s2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return s;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long minWithOrNull(long[] jArr, Comparator<? super Long> comparator) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (comparator.compare(Long.valueOf(j), Long.valueOf(j2)) > 0) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Boolean randomOrNull(boolean[] zArr, Random random) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
return Boolean.valueOf(zArr[random.nextInt(zArr.length)]);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double reduceRightIndexedOrNull(double[] dArr, Function3<? super Integer, ? super Double, ? super Double, Double> function3) {.swift
int lastIndex = getLastIndex(dArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
double d = dArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
d = function3.invoke(Integer.valueOf(i), Double.valueOf(dArr[i]), Double.valueOf(d)).doubleValue();.swift
}.swift
return Double.valueOf(d);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double reduceRightOrNull(double[] dArr, Function2<? super Double, ? super Double, Double> function2) {.swift
int lastIndex = getLastIndex(dArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
double d = dArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
d = function2.invoke(Double.valueOf(dArr[i]), Double.valueOf(d)).doubleValue();.swift
}.swift
return Double.valueOf(d);.swift
}.swift
public static final Float singleOrNull(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
Float f = null;.swift
boolean z = false;.swift
for (float f2 : fArr) {.swift
if (function1.invoke(Float.valueOf(f2)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
f = Float.valueOf(f2);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return f;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(byte[] bArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(bArr, i, i2);.swift
reverse(bArr, i, i2);.swift
}.swift
public static final <K, V> Map<K, V> associate(double[] dArr, Function1<? super Double, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(dArr.length), 16));.swift
for (double valueOf : dArr) {.swift
Pair pair = (Pair) function1.invoke(Double.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Double> associateBy(double[] dArr, Function1<? super Double, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(dArr.length), 16));.swift
for (double d : dArr) {.swift
linkedHashMap.put(function1.invoke(Double.valueOf(d)), Double.valueOf(d));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(int[] iArr, M m, Function1<? super Integer, ? extends K> function1, Function1<? super Integer, ? extends V> function12) {.swift
for (int i : iArr) {.swift
m.put(function1.invoke(Integer.valueOf(i)), function12.invoke(Integer.valueOf(i)));.swift
}.swift
return m;.swift
}.swift
public static final <K> List<Long> distinctBy(long[] jArr, Function1<? super Long, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (long j : jArr) {.swift
if (hashSet.add(function1.invoke(Long.valueOf(j)))) {.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Double> dropLastWhile(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(dArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Double.valueOf(dArr[lastIndex])).booleanValue()) {.swift
return take(dArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final List<Character> filterIndexed(char[] cArr, Function2<? super Integer, ? super Character, Boolean> function2) {.swift
ArrayList arrayList = new ArrayList();.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
char c = cArr[i];.swift
int i3 = i2 + 1;.swift
if (function2.invoke(Integer.valueOf(i2), Character.valueOf(c)).booleanValue()) {.swift
arrayList.add(Character.valueOf(c));.swift
}.swift
i++;.swift
i2 = i3;.swift
}.swift
return arrayList;.swift
}.swift
@InlineOnly.swift
private static final Character findLast(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
int length = cArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
char c = cArr[length];.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
return Character.valueOf(c);.swift
}.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
}.swift
}.swift
return null;.swift
}.swift
public static final char first(char[] cArr) {.swift
if (cArr.length = 0) {.swift
return cArr[0];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final <R> List<R> flatMap(double[] dArr, Function1<? super Double, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (double valueOf : dArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Double.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
@JvmName(name = "flatMapIndexedIterableTo").swift
private static final <R, C extends Collection<? super R>> C flatMapIndexedIterableTo(char[] cArr, C c, Function2<? super Integer, ? super Character, ? extends Iterable<? extends R>> function2) {.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function2.invoke(Integer.valueOf(i2), Character.valueOf(cArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return c;.swift
}.swift
public static final <R, C extends Collection<? super R>> C flatMapTo(char[] cArr, C c, Function1<? super Character, ? extends Iterable<? extends R>> function1) {.swift
for (char valueOf : cArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(c, (Iterable) function1.invoke(Character.valueOf(valueOf)));.swift
}.swift
return c;.swift
}.swift
public static final char last(char[] cArr) {.swift
if (cArr.length = 0) {.swift
return cArr[getLastIndex(cArr)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final Float lastOrNull(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
int length = fArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
float f = fArr[length];.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
return Float.valueOf(f);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
public static final <R> List<R> map(char[] cArr, Function1<? super Character, ? extends R> function1) {.swift
ArrayList arrayList = new ArrayList(cArr.length);.swift
for (char valueOf : cArr) {.swift
arrayList.add(function1.invoke(Character.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
public static final <R> List<R> mapIndexed(char[] cArr, Function2<? super Integer, ? super Character, ? extends R> function2) {.swift
ArrayList arrayList = new ArrayList(cArr.length);.swift
int length = cArr.length;.swift
int i = 0;.swift
int i2 = 0;.swift
while (i < length) {.swift
arrayList.add(function2.invoke(Integer.valueOf(i2), Character.valueOf(cArr[i])));.swift
i++;.swift
i2++;.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxByOrThrow").swift
public static final <R extends Comparable<? super R>> int maxByOrThrow(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex == 0) {.swift
return i;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Integer.valueOf(i));.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
Comparable comparable2 = (Comparable) function1.invoke(Integer.valueOf(i3));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
i = i3;.swift
comparable = comparable2;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double maxOf(long[] jArr, Function1<? super Long, Double> function1) {.swift
if (jArr.length = 0) {.swift
double doubleValue = function1.invoke(Long.valueOf(jArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Long.valueOf(jArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final Double m401maxOfOrNull(long[] jArr, Function1<? super Long, Double> function1) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Long.valueOf(jArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Long.valueOf(jArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWith(long[] jArr, Comparator<? super R> comparator, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length = 0) {.swift
R invoke = function1.invoke(Long.valueOf(jArr[0]));.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Long.valueOf(jArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final long maxWithOrThrow(long[] jArr, Comparator<? super Long> comparator) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (comparator.compare(Long.valueOf(j), Long.valueOf(j2)) < 0) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minByOrThrow").swift
public static final <R extends Comparable<? super R>> int minByOrThrow(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex == 0) {.swift
return i;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Integer.valueOf(i));.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
Comparable comparable2 = (Comparable) function1.invoke(Integer.valueOf(i3));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
i = i3;.swift
comparable = comparable2;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double minOf(long[] jArr, Function1<? super Long, Double> function1) {.swift
if (jArr.length = 0) {.swift
double doubleValue = function1.invoke(Long.valueOf(jArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Long.valueOf(jArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final Double m437minOfOrNull(long[] jArr, Function1<? super Long, Double> function1) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Long.valueOf(jArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Long.valueOf(jArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWith(long[] jArr, Comparator<? super R> comparator, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length = 0) {.swift
R invoke = function1.invoke(Long.valueOf(jArr[0]));.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Long.valueOf(jArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final long minWithOrThrow(long[] jArr, Comparator<? super Long> comparator) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (comparator.compare(Long.valueOf(j), Long.valueOf(j2)) > 0) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final float random(float[] fArr, Random random) {.swift
if (fArr.length = 0) {.swift
return fArr[random.nextInt(fArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float reduceIndexedOrNull(float[] fArr, Function3<? super Integer, ? super Float, ? super Float, Float> function3) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
f = function3.invoke(Integer.valueOf(i), Float.valueOf(f), Float.valueOf(fArr[i])).floatValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Float.valueOf(f);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float reduceOrNull(float[] fArr, Function2<? super Float, ? super Float, Float> function2) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
f = function2.invoke(Float.valueOf(f), Float.valueOf(fArr[i])).floatValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Float.valueOf(f);.swift
}.swift
public static final double reduceRight(double[] dArr, Function2<? super Double, ? super Double, Double> function2) {.swift
int lastIndex = getLastIndex(dArr);.swift
if (lastIndex >= 0) {.swift
double d = dArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
d = function2.invoke(Double.valueOf(dArr[i]), Double.valueOf(d)).doubleValue();.swift
}.swift
return d;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final double reduceRightIndexed(double[] dArr, Function3<? super Integer, ? super Double, ? super Double, Double> function3) {.swift
int lastIndex = getLastIndex(dArr);.swift
if (lastIndex >= 0) {.swift
double d = dArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
d = function3.invoke(Integer.valueOf(i), Double.valueOf(dArr[i]), Double.valueOf(d)).doubleValue();.swift
}.swift
return d;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final List<Character> reversed(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
List<Character> mutableList = toMutableList(cArr);.swift
CollectionsKt___CollectionsJvmKt.reverse(mutableList);.swift
return mutableList;.swift
}.swift
public static final double[] reversedArray(double[] dArr) {.swift
if (dArr.length == 0) {.swift
return dArr;.swift
}.swift
double[] dArr2 = new double[dArr.length];.swift
int lastIndex = getLastIndex(dArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
dArr2[lastIndex - i] = dArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return dArr2;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Long> runningReduce(long[] jArr, Function2<? super Long, ? super Long, Long> function2) {.swift
if (jArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
long j = jArr[0];.swift
ArrayList arrayList = new ArrayList(jArr.length);.swift
arrayList.add(Long.valueOf(j));.swift
int length = jArr.length;.swift
for (int i = 1; i < length; i++) {.swift
j = function2.invoke(Long.valueOf(j), Long.valueOf(jArr[i])).longValue();.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Long> runningReduceIndexed(long[] jArr, Function3<? super Integer, ? super Long, ? super Long, Long> function3) {.swift
if (jArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
long j = jArr[0];.swift
ArrayList arrayList = new ArrayList(jArr.length);.swift
arrayList.add(Long.valueOf(j));.swift
int length = jArr.length;.swift
for (int i = 1; i < length; i++) {.swift
j = function3.invoke(Integer.valueOf(i), Long.valueOf(j), Long.valueOf(jArr[i])).longValue();.swift
arrayList.add(Long.valueOf(j));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(int[] iArr, Random random) {.swift
for (int lastIndex = getLastIndex(iArr); lastIndex > 0; lastIndex--) {.swift
int nextInt = random.nextInt(lastIndex + 1);.swift
int i = iArr[lastIndex];.swift
iArr[lastIndex] = iArr[nextInt];.swift
iArr[nextInt] = i;.swift
}.swift
}.swift
public static final double single(double[] dArr) {.swift
int length = dArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return dArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final List<Long> slice(long[] jArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList(ArraysKt___ArraysJvmKt.copyOfRange(jArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
public static final char[] sliceArray(char[] cArr, Collection<Integer> collection) {.swift
char[] cArr2 = new char[collection.size()];.swift
int i = 0;.swift
for (Integer intValue : collection) {.swift
cArr2[i] = cArr[intValue.intValue()];.swift
i++;.swift
}.swift
return cArr2;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final int sumOfUInt(long[] jArr, Function1<? super Long, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (long valueOf : jArr) {.swift
r1 = tr1.g(function1.invoke(Long.valueOf(valueOf)), r1);.swift
}.swift
return r1;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfULong").swift
private static final long sumOfULong(char[] cArr, Function1<? super Character, ULong> function1) {.swift
long r0 = ULong.m197constructorimpl(0);.swift
for (char valueOf : cArr) {.swift
r0 = ULong.m197constructorimpl(function1.invoke(Character.valueOf(valueOf)).m249unboximpl() + r0);.swift
}.swift
return r0;.swift
}.swift
public static final List<Double> takeLastWhile(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(dArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Double.valueOf(dArr[lastIndex])).booleanValue()) {.swift
return drop(dArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(dArr);.swift
}.swift
public static final List<Double> takeWhile(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (double d : dArr) {.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Double> toList(double[] dArr) {.swift
int length = dArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(dArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Double.valueOf(dArr[0]));.swift
}.swift
public static final Set<Double> toSet(double[] dArr) {.swift
int length = dArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(dArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(dArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Double.valueOf(dArr[0]));.swift
}.swift
public static final <R, V> List<V> zip(char[] cArr, R[] rArr, Function2<? super Character, ? super R, ? extends V> function2) {.swift
int min = Math.min(cArr.length, rArr.length);.swift
ArrayList arrayList = new ArrayList(min);.swift
for (int i = 0; i < min; i++) {.swift
arrayList.add(function2.invoke(Character.valueOf(cArr[i]), rArr[i]));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Float> dropWhile(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (float f : fArr) {.swift
if (z) {.swift
arrayList.add(Float.valueOf(f));.swift
} else if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
arrayList.add(Float.valueOf(f));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Integer maxByOrNull(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex == 0) {.swift
return Integer.valueOf(i);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Integer.valueOf(i));.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
Comparable comparable2 = (Comparable) function1.invoke(Integer.valueOf(i3));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
i = i3;.swift
comparable = comparable2;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(float[] fArr, Comparator<? super R> comparator, Function1<? super Float, ? extends R> function1) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Float.valueOf(fArr[0]));.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Float.valueOf(fArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Integer minByOrNull(int[] iArr, Function1<? super Integer, ? extends R> function1) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
if (lastIndex == 0) {.swift
return Integer.valueOf(i);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Integer.valueOf(i));.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
Comparable comparable2 = (Comparable) function1.invoke(Integer.valueOf(i3));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
i = i3;.swift
comparable = comparable2;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(float[] fArr, Comparator<? super R> comparator, Function1<? super Float, ? extends R> function1) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Float.valueOf(fArr[0]));.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Float.valueOf(fArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Character randomOrNull(char[] cArr, Random random) {.swift
if (cArr.length == 0) {.swift
return null;.swift
}.swift
return Character.valueOf(cArr[random.nextInt(cArr.length)]);.swift
}.swift
public static final float reduce(float[] fArr, Function2<? super Float, ? super Float, Float> function2) {.swift
if (fArr.length = 0) {.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
f = function2.invoke(Float.valueOf(f), Float.valueOf(fArr[i])).floatValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return f;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final float reduceIndexed(float[] fArr, Function3<? super Integer, ? super Float, ? super Float, Float> function3) {.swift
if (fArr.length = 0) {.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
f = function3.invoke(Integer.valueOf(i), Float.valueOf(f), Float.valueOf(fArr[i])).floatValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return f;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final void reverse(float[] fArr) {.swift
int length = (fArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(fArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
float f = fArr[i];.swift
fArr[i] = fArr[lastIndex];.swift
fArr[lastIndex] = f;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Float, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(float[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Float, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
return r4.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r4[r2].swift
java.lang.Float r3 = java.lang.Float.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(float[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Float, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(float[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Float, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r5[r2].swift
java.lang.Float r4 = java.lang.Float.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(float[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(short[] sArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(sArr, i, i2);.swift
reverse(sArr, i, i2);.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(long[] jArr, M m, Function1<? super Long, ? extends K> function1, Function1<? super Long, ? extends V> function12) {.swift
for (long j : jArr) {.swift
m.put(function1.invoke(Long.valueOf(j)), function12.invoke(Long.valueOf(j)));.swift
}.swift
return m;.swift
}.swift
public static final Double singleOrNull(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
Double d = null;.swift
boolean z = false;.swift
for (double d2 : dArr) {.swift
if (function1.invoke(Double.valueOf(d2)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
d = Double.valueOf(d2);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return d;.swift
}.swift
public static final List<Integer> drop(int[] iArr, int i) {.swift
if (i >= 0) {.swift
return takeLast(iArr, RangesKt.coerceAtLeast(iArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final List<Integer> dropLast(int[] iArr, int i) {.swift
if (i >= 0) {.swift
return take(iArr, RangesKt.coerceAtLeast(iArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final <T> T first(T[] tArr, Function1<? super T, Boolean> function1) {.swift
for (T t : tArr) {.swift
if (function1.invoke(t).booleanValue()) {.swift
return t;.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
public static final <K, M extends Map<? super K, List<Integer>>> M groupByTo(int[] iArr, M m, Function1<? super Integer, ? extends K> function1) {.swift
for (int i : iArr) {.swift
Object invoke = function1.invoke(Integer.valueOf(i));.swift
Object obj = m.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.r(m, invoke);.swift
}.swift
((List) obj).add(Integer.valueOf(i));.swift
}.swift
return m;.swift
}.swift
public static final <A extends Appendable> A joinTo(long[] jArr, A a, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Long, ? extends CharSequence> function1) {.swift
a.append(charSequence2);.swift
int i2 = 0;.swift
for (long j : jArr) {.swift
i2++;.swift
if (i2 > 1) {.swift
a.append(charSequence);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
break;.swift
}.swift
if (function1 = null) {.swift
a.append((CharSequence) function1.invoke(Long.valueOf(j)));.swift
} else {.swift
a.append(String.valueOf(j));.swift
}.swift
}.swift
if (i >= 0 && i2 > i) {.swift
a.append(charSequence4);.swift
}.swift
a.append(charSequence3);.swift
return a;.swift
}.swift
public static final <T> T last(T[] tArr, Function1<? super T, Boolean> function1) {.swift
int length = tArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
T t = tArr[length];.swift
if (function1.invoke(t).booleanValue()) {.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
} else {.swift
return t;.swift
}.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
public static final Double lastOrNull(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
int length = dArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
double d = dArr[length];.swift
if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
return Double.valueOf(d);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer maxOrNull(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (i < i3) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Integer minOrNull(int[] iArr) {.swift
if (iArr.length == 0) {.swift
return null;.swift
}.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (i > i3) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return Integer.valueOf(i);.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final double random(double[] dArr, Random random) {.swift
if (dArr.length = 0) {.swift
return dArr[random.nextInt(dArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Boolean reduceRightIndexedOrNull(boolean[] zArr, Function3<? super Integer, ? super Boolean, ? super Boolean, Boolean> function3) {.swift
int lastIndex = getLastIndex(zArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
boolean z = zArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
z = function3.invoke(Integer.valueOf(i), Boolean.valueOf(zArr[i]), Boolean.valueOf(z)).booleanValue();.swift
}.swift
return Boolean.valueOf(z);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Boolean reduceRightOrNull(boolean[] zArr, Function2<? super Boolean, ? super Boolean, Boolean> function2) {.swift
int lastIndex = getLastIndex(zArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
boolean z = zArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
z = function2.invoke(Boolean.valueOf(zArr[i]), Boolean.valueOf(z)).booleanValue();.swift
}.swift
return Boolean.valueOf(z);.swift
}.swift
public static final <T> T[] sliceArray(T[] tArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return ArraysKt___ArraysJvmKt.copyOfRange(tArr, 0, 0);.swift
}.swift
return ArraysKt___ArraysJvmKt.copyOfRange(tArr, intRange.getStart().intValue(), tr1.f(1, intRange));.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(int[] iArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(iArr, i, i2);.swift
reverse(iArr, i, i2);.swift
}.swift
public static final <T, R, V> List<V> zip(T[] tArr, Iterable<? extends R> iterable, Function2<? super T, ? super R, ? extends V> function2) {.swift
int length = tArr.length;.swift
ArrayList arrayList = new ArrayList(Math.min(CollectionsKt__IterablesKt.collectionSizeOrDefault(iterable, 10), length));.swift
int i = 0;.swift
for (Object next : iterable) {.swift
if (i >= length) {.swift
break;.swift
}.swift
arrayList.add(function2.invoke(tArr[i], next));.swift
i++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <K, V> Map<K, V> associate(boolean[] zArr, Function1<? super Boolean, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(zArr.length), 16));.swift
for (boolean valueOf : zArr) {.swift
Pair pair = (Pair) function1.invoke(Boolean.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Boolean> associateBy(boolean[] zArr, Function1<? super Boolean, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(zArr.length), 16));.swift
for (boolean z : zArr) {.swift
linkedHashMap.put(function1.invoke(Boolean.valueOf(z)), Boolean.valueOf(z));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(float[] fArr, M m, Function1<? super Float, ? extends K> function1, Function1<? super Float, ? extends V> function12) {.swift
for (float f : fArr) {.swift
m.put(function1.invoke(Float.valueOf(f)), function12.invoke(Float.valueOf(f)));.swift
}.swift
return m;.swift
}.swift
public static final List<Boolean> dropLastWhile(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(zArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Boolean.valueOf(zArr[lastIndex])).booleanValue()) {.swift
return take(zArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final <R> List<R> flatMap(boolean[] zArr, Function1<? super Boolean, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (boolean valueOf : zArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Boolean.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final int maxOrThrow(int[] iArr) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (i < i3) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final int minOrThrow(int[] iArr) {.swift
if (iArr.length = 0) {.swift
int i = iArr[0];.swift
int lastIndex = getLastIndex(iArr);.swift
int i2 = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
int i3 = iArr[i2];.swift
if (i > i3) {.swift
i = i3;.swift
}.swift
if (i2 == lastIndex) {.swift
break;.swift
}.swift
i2++;.swift
}.swift
}.swift
return i;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
public static final Pair<List<Long>, List<Long>> partition(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
ArrayList arrayList2 = new ArrayList();.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
arrayList.add(Long.valueOf(j));.swift
} else {.swift
arrayList2.add(Long.valueOf(j));.swift
}.swift
}.swift
return new Pair<>(arrayList, arrayList2);.swift
}.swift
public static final boolean reduceRight(boolean[] zArr, Function2<? super Boolean, ? super Boolean, Boolean> function2) {.swift
int lastIndex = getLastIndex(zArr);.swift
if (lastIndex >= 0) {.swift
boolean z = zArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
z = function2.invoke(Boolean.valueOf(zArr[i]), Boolean.valueOf(z)).booleanValue();.swift
}.swift
return z;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final boolean reduceRightIndexed(boolean[] zArr, Function3<? super Integer, ? super Boolean, ? super Boolean, Boolean> function3) {.swift
int lastIndex = getLastIndex(zArr);.swift
if (lastIndex >= 0) {.swift
boolean z = zArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
z = function3.invoke(Integer.valueOf(i), Boolean.valueOf(zArr[i]), Boolean.valueOf(z)).booleanValue();.swift
}.swift
return z;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final boolean[] reversedArray(boolean[] zArr) {.swift
if (zArr.length == 0) {.swift
return zArr;.swift
}.swift
boolean[] zArr2 = new boolean[zArr.length];.swift
int lastIndex = getLastIndex(zArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
zArr2[lastIndex - i] = zArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return zArr2;.swift
}.swift
public static final boolean single(boolean[] zArr) {.swift
int length = zArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return zArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final List<Short> take(short[] sArr, int i) {.swift
if (i < 0) {.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
} else if (i == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
} else {.swift
if (i >= sArr.length) {.swift
return toList(sArr);.swift
}.swift
if (i == 1) {.swift
return CollectionsKt__CollectionsJVMKt.listOf(Short.valueOf(sArr[0]));.swift
}.swift
ArrayList arrayList = new ArrayList(i);.swift
int i2 = 0;.swift
for (short valueOf : sArr) {.swift
arrayList.add(Short.valueOf(valueOf));.swift
i2++;.swift
if (i2 == i) {.swift
break;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
}.swift
public static final List<Short> takeLast(short[] sArr, int i) {.swift
if (i < 0) {.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
} else if (i == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
} else {.swift
int length = sArr.length;.swift
if (i >= length) {.swift
return toList(sArr);.swift
}.swift
if (i == 1) {.swift
return CollectionsKt__CollectionsJVMKt.listOf(Short.valueOf(sArr[length - 1]));.swift
}.swift
ArrayList arrayList = new ArrayList(i);.swift
for (int i2 = length - i; i2 < length; i2++) {.swift
arrayList.add(Short.valueOf(sArr[i2]));.swift
}.swift
return arrayList;.swift
}.swift
}.swift
public static final List<Boolean> takeLastWhile(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(zArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Boolean.valueOf(zArr[lastIndex])).booleanValue()) {.swift
return drop(zArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(zArr);.swift
}.swift
public static final List<Boolean> takeWhile(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (boolean z : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Boolean.valueOf(z));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Boolean> toList(boolean[] zArr) {.swift
int length = zArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(zArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Boolean.valueOf(zArr[0]));.swift
}.swift
public static final Set<Boolean> toSet(boolean[] zArr) {.swift
int length = zArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(zArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(zArr.length)));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Boolean.valueOf(zArr[0]));.swift
}.swift
public static final byte first(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
for (byte b : bArr) {.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
return b;.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float maxWithOrNull(float[] fArr, Comparator<? super Float> comparator) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
float f2 = fArr[i];.swift
if (comparator.compare(Float.valueOf(f), Float.valueOf(f2)) < 0) {.swift
f = f2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Float.valueOf(f);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Float minWithOrNull(float[] fArr, Comparator<? super Float> comparator) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
float f2 = fArr[i];.swift
if (comparator.compare(Float.valueOf(f), Float.valueOf(f2)) > 0) {.swift
f = f2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Float.valueOf(f);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double reduceIndexedOrNull(double[] dArr, Function3<? super Integer, ? super Double, ? super Double, Double> function3) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
d = function3.invoke(Integer.valueOf(i), Double.valueOf(d), Double.valueOf(dArr[i])).doubleValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(d);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double reduceOrNull(double[] dArr, Function2<? super Double, ? super Double, Double> function2) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
d = function2.invoke(Double.valueOf(d), Double.valueOf(dArr[i])).doubleValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(d);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(long[] jArr, Random random) {.swift
for (int lastIndex = getLastIndex(jArr); lastIndex > 0; lastIndex--) {.swift
int nextInt = random.nextInt(lastIndex + 1);.swift
long j = jArr[lastIndex];.swift
jArr[lastIndex] = jArr[nextInt];.swift
jArr[nextInt] = j;.swift
}.swift
}.swift
public static final Boolean singleOrNull(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
Boolean bool = null;.swift
boolean z = false;.swift
for (boolean z2 : zArr) {.swift
if (function1.invoke(Boolean.valueOf(z2)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
bool = Boolean.valueOf(z2);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return bool;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(long[] jArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(jArr, i, i2);.swift
reverse(jArr, i, i2);.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(double[] dArr, M m, Function1<? super Double, ? extends K> function1, Function1<? super Double, ? extends V> function12) {.swift
for (double d : dArr) {.swift
m.put(function1.invoke(Double.valueOf(d)), function12.invoke(Double.valueOf(d)));.swift
}.swift
return m;.swift
}.swift
public static final <K> List<Float> distinctBy(float[] fArr, Function1<? super Float, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (float f : fArr) {.swift
if (hashSet.add(function1.invoke(Float.valueOf(f)))) {.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Double> dropWhile(double[] dArr, Function1<? super Double, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (double d : dArr) {.swift
if (z) {.swift
arrayList.add(Double.valueOf(d));.swift
} else if (function1.invoke(Double.valueOf(d)).booleanValue()) {.swift
arrayList.add(Double.valueOf(d));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final <K> Map<K, List<Integer>> groupBy(int[] iArr, Function1<? super Integer, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap();.swift
for (int i : iArr) {.swift
Object invoke = function1.invoke(Integer.valueOf(i));.swift
Object obj = linkedHashMap.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.q(linkedHashMap, invoke);.swift
}.swift
((List) obj).add(Integer.valueOf(i));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final Boolean lastOrNull(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
int length = zArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
boolean z = zArr[length];.swift
if (function1.invoke(Boolean.valueOf(z)).booleanValue()) {.swift
return Boolean.valueOf(z);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double maxOf(float[] fArr, Function1<? super Float, Double> function1) {.swift
if (fArr.length = 0) {.swift
double doubleValue = function1.invoke(Float.valueOf(fArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Float.valueOf(fArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final Double m399maxOfOrNull(float[] fArr, Function1<? super Float, Double> function1) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Float.valueOf(fArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Float.valueOf(fArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWith(float[] fArr, Comparator<? super R> comparator, Function1<? super Float, ? extends R> function1) {.swift
if (fArr.length = 0) {.swift
R invoke = function1.invoke(Float.valueOf(fArr[0]));.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Float.valueOf(fArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(double[] dArr, Comparator<? super R> comparator, Function1<? super Double, ? extends R> function1) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Double.valueOf(dArr[0]));.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Double.valueOf(dArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final float maxWithOrThrow(float[] fArr, Comparator<? super Float> comparator) {.swift
if (fArr.length = 0) {.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
float f2 = fArr[i];.swift
if (comparator.compare(Float.valueOf(f), Float.valueOf(f2)) < 0) {.swift
f = f2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return f;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double minOf(float[] fArr, Function1<? super Float, Double> function1) {.swift
if (fArr.length = 0) {.swift
double doubleValue = function1.invoke(Float.valueOf(fArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Float.valueOf(fArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final Double m435minOfOrNull(float[] fArr, Function1<? super Float, Double> function1) {.swift
if (fArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Float.valueOf(fArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Float.valueOf(fArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWith(float[] fArr, Comparator<? super R> comparator, Function1<? super Float, ? extends R> function1) {.swift
if (fArr.length = 0) {.swift
R invoke = function1.invoke(Float.valueOf(fArr[0]));.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Float.valueOf(fArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(double[] dArr, Comparator<? super R> comparator, Function1<? super Double, ? extends R> function1) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Double.valueOf(dArr[0]));.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Double.valueOf(dArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final float minWithOrThrow(float[] fArr, Comparator<? super Float> comparator) {.swift
if (fArr.length = 0) {.swift
float f = fArr[0];.swift
int lastIndex = getLastIndex(fArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
float f2 = fArr[i];.swift
if (comparator.compare(Float.valueOf(f), Float.valueOf(f2)) > 0) {.swift
f = f2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return f;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final boolean random(boolean[] zArr, Random random) {.swift
if (zArr.length = 0) {.swift
return zArr[random.nextInt(zArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static final double reduce(double[] dArr, Function2<? super Double, ? super Double, Double> function2) {.swift
if (dArr.length = 0) {.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
d = function2.invoke(Double.valueOf(d), Double.valueOf(dArr[i])).doubleValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return d;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final double reduceIndexed(double[] dArr, Function3<? super Integer, ? super Double, ? super Double, Double> function3) {.swift
if (dArr.length = 0) {.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
d = function3.invoke(Integer.valueOf(i), Double.valueOf(d), Double.valueOf(dArr[i])).doubleValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return d;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final void reverse(double[] dArr) {.swift
int length = (dArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(dArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
double d = dArr[i];.swift
dArr[i] = dArr[lastIndex];.swift
dArr[lastIndex] = d;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Double, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(double[] r5, R r6, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Double, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
r3 = r5[r2].swift
java.lang.Double r3 = java.lang.Double.valueOf(r3).swift
java.lang.Object r6 = r7.invoke(r6, r3).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(double[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r8v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Double, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(double[] r6, R r7, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Double, ? extends R> r8) {.swift
/*.swift
int r0 = r6.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r6 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r7).swift
return r6.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r6.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r7).swift
int r1 = r6.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
r4 = r6[r2].swift
java.lang.Double r4 = java.lang.Double.valueOf(r4).swift
java.lang.Object r7 = r8.invoke(r3, r7, r4).swift
r0.add(r7).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(double[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Float> runningReduce(float[] fArr, Function2<? super Float, ? super Float, Float> function2) {.swift
if (fArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
float f = fArr[0];.swift
ArrayList arrayList = new ArrayList(fArr.length);.swift
arrayList.add(Float.valueOf(f));.swift
int length = fArr.length;.swift
for (int i = 1; i < length; i++) {.swift
f = function2.invoke(Float.valueOf(f), Float.valueOf(fArr[i])).floatValue();.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Float> runningReduceIndexed(float[] fArr, Function3<? super Integer, ? super Float, ? super Float, Float> function3) {.swift
if (fArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
float f = fArr[0];.swift
ArrayList arrayList = new ArrayList(fArr.length);.swift
arrayList.add(Float.valueOf(f));.swift
int length = fArr.length;.swift
for (int i = 1; i < length; i++) {.swift
f = function3.invoke(Integer.valueOf(i), Float.valueOf(f), Float.valueOf(fArr[i])).floatValue();.swift
arrayList.add(Float.valueOf(f));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Float> slice(float[] fArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList(ArraysKt___ArraysJvmKt.copyOfRange(fArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final int sumOfUInt(float[] fArr, Function1<? super Float, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (float valueOf : fArr) {.swift
r1 = tr1.g(function1.invoke(Float.valueOf(valueOf)), r1);.swift
}.swift
return r1;.swift
}.swift
public static final short first(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
for (short s : sArr) {.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
return s;.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
public static final byte last(byte[] bArr, Function1<? super Byte, Boolean> function1) {.swift
int length = bArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
byte b = bArr[length];.swift
if (function1.invoke(Byte.valueOf(b)).booleanValue()) {.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
} else {.swift
return b;.swift
}.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Character reduceRightIndexedOrNull(char[] cArr, Function3<? super Integer, ? super Character, ? super Character, Character> function3) {.swift
int lastIndex = getLastIndex(cArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
char c = cArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
c = function3.invoke(Integer.valueOf(i), Character.valueOf(cArr[i]), Character.valueOf(c)).charValue();.swift
}.swift
return Character.valueOf(c);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Character reduceRightOrNull(char[] cArr, Function2<? super Character, ? super Character, Character> function2) {.swift
int lastIndex = getLastIndex(cArr);.swift
if (lastIndex < 0) {.swift
return null;.swift
}.swift
char c = cArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
c = function2.invoke(Character.valueOf(cArr[i]), Character.valueOf(c)).charValue();.swift
}.swift
return Character.valueOf(c);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(float[] fArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(fArr, i, i2);.swift
reverse(fArr, i, i2);.swift
}.swift
public static final <R, V> List<V> zip(byte[] bArr, Iterable<? extends R> iterable, Function2<? super Byte, ? super R, ? extends V> function2) {.swift
int length = bArr.length;.swift
ArrayList arrayList = new ArrayList(Math.min(CollectionsKt__IterablesKt.collectionSizeOrDefault(iterable, 10), length));.swift
int i = 0;.swift
for (Object next : iterable) {.swift
if (i >= length) {.swift
break;.swift
}.swift
arrayList.add(function2.invoke(Byte.valueOf(bArr[i]), next));.swift
i++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <K, V> Map<K, V> associate(char[] cArr, Function1<? super Character, ? extends Pair<? extends K, ? extends V>> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(cArr.length), 16));.swift
for (char valueOf : cArr) {.swift
Pair pair = (Pair) function1.invoke(Character.valueOf(valueOf));.swift
linkedHashMap.put(pair.getFirst(), pair.getSecond());.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> Map<K, Character> associateBy(char[] cArr, Function1<? super Character, ? extends K> function1) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(cArr.length), 16));.swift
for (char c : cArr) {.swift
linkedHashMap.put(function1.invoke(Character.valueOf(c)), Character.valueOf(c));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(boolean[] zArr, M m, Function1<? super Boolean, ? extends K> function1, Function1<? super Boolean, ? extends V> function12) {.swift
for (boolean z : zArr) {.swift
m.put(function1.invoke(Boolean.valueOf(z)), function12.invoke(Boolean.valueOf(z)));.swift
}.swift
return m;.swift
}.swift
public static final List<Character> dropLastWhile(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(cArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Character.valueOf(cArr[lastIndex])).booleanValue()) {.swift
return take(cArr, lastIndex + 1);.swift
}.swift
}.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
public static final <R> List<R> flatMap(char[] cArr, Function1<? super Character, ? extends Iterable<? extends R>> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (char valueOf : cArr) {.swift
CollectionsKt__MutableCollectionsKt.addAll(arrayList, (Iterable) function1.invoke(Character.valueOf(valueOf)));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxByOrThrow").swift
public static final <R extends Comparable<? super R>> long maxByOrThrow(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex == 0) {.swift
return j;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Long.valueOf(j));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Long.valueOf(j2));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
j = j2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long maxOrNull(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (j < j2) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minByOrThrow").swift
public static final <R extends Comparable<? super R>> long minByOrThrow(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex == 0) {.swift
return j;.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Long.valueOf(j));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Long.valueOf(j2));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
j = j2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Long minOrNull(long[] jArr) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (j > j2) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
public static final char reduceRight(char[] cArr, Function2<? super Character, ? super Character, Character> function2) {.swift
int lastIndex = getLastIndex(cArr);.swift
if (lastIndex >= 0) {.swift
char c = cArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
c = function2.invoke(Character.valueOf(cArr[i]), Character.valueOf(c)).charValue();.swift
}.swift
return c;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final char reduceRightIndexed(char[] cArr, Function3<? super Integer, ? super Character, ? super Character, Character> function3) {.swift
int lastIndex = getLastIndex(cArr);.swift
if (lastIndex >= 0) {.swift
char c = cArr[lastIndex];.swift
for (int i = lastIndex - 1; i >= 0; i--) {.swift
c = function3.invoke(Integer.valueOf(i), Character.valueOf(cArr[i]), Character.valueOf(c)).charValue();.swift
}.swift
return c;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final char[] reversedArray(char[] cArr) {.swift
if (cArr.length == 0) {.swift
return cArr;.swift
}.swift
char[] cArr2 = new char[cArr.length];.swift
int lastIndex = getLastIndex(cArr);.swift
if (lastIndex >= 0) {.swift
int i = 0;.swift
while (true) {.swift
cArr2[lastIndex - i] = cArr[i];.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return cArr2;.swift
}.swift
public static char single(char[] cArr) {.swift
int length = cArr.length;.swift
if (length == 0) {.swift
throw new NoSuchElementException("Array is empty.");.swift
} else if (length == 1) {.swift
return cArr[0];.swift
} else {.swift
throw new IllegalArgumentException("Array has more than one element.");.swift
}.swift
}.swift
public static final Character singleOrNull(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
Character ch = null;.swift
boolean z = false;.swift
for (char c : cArr) {.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
if (z) {.swift
return null;.swift
}.swift
ch = Character.valueOf(c);.swift
z = true;.swift
}.swift
}.swift
if (z) {.swift
return null;.swift
}.swift
return ch;.swift
}.swift
public static final List<Character> takeLastWhile(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
for (int lastIndex = getLastIndex(cArr); -1 < lastIndex; lastIndex--) {.swift
if (function1.invoke(Character.valueOf(cArr[lastIndex])).booleanValue()) {.swift
return drop(cArr, lastIndex + 1);.swift
}.swift
}.swift
return toList(cArr);.swift
}.swift
public static final List<Character> takeWhile(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
for (char c : cArr) {.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
break;.swift
}.swift
arrayList.add(Character.valueOf(c));.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Character> toList(char[] cArr) {.swift
int length = cArr.length;.swift
if (length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
if (length = 1) {.swift
return toMutableList(cArr);.swift
}.swift
return CollectionsKt__CollectionsJVMKt.listOf(Character.valueOf(cArr[0]));.swift
}.swift
public static final Set<Character> toSet(char[] cArr) {.swift
int length = cArr.length;.swift
if (length == 0) {.swift
return SetsKt__SetsKt.emptySet();.swift
}.swift
if (length = 1) {.swift
return (Set) toCollection(cArr, new LinkedHashSet(MapsKt__MapsJVMKt.mapCapacity(RangesKt.coerceAtMost(cArr.length, (int) Uuid.SIZE_BITS))));.swift
}.swift
return SetsKt__SetsJVMKt.setOf(Character.valueOf(cArr[0]));.swift
}.swift
public static final int first(int[] iArr, Function1<? super Integer, Boolean> function1) {.swift
for (int i : iArr) {.swift
if (function1.invoke(Integer.valueOf(i)).booleanValue()) {.swift
return i;.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
public static final Character lastOrNull(char[] cArr, Function1<? super Character, Boolean> function1) {.swift
int length = cArr.length - 1;.swift
if (length < 0) {.swift
return null;.swift
}.swift
while (true) {.swift
int i = length - 1;.swift
char c = cArr[length];.swift
if (function1.invoke(Character.valueOf(c)).booleanValue()) {.swift
return Character.valueOf(c);.swift
}.swift
if (i < 0) {.swift
return null;.swift
}.swift
length = i;.swift
}.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxOrThrow").swift
public static final long maxOrThrow(long[] jArr) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (j < j2) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minOrThrow").swift
public static final long minOrThrow(long[] jArr) {.swift
if (jArr.length = 0) {.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
if (j > j2) {.swift
j = j2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return j;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.3").swift
public static final char random(char[] cArr, Random random) {.swift
if (cArr.length = 0) {.swift
return cArr[random.nextInt(cArr.length)];.swift
}.swift
throw new NoSuchElementException("Array is empty.");.swift
}.swift
public static byte[] sliceArray(byte[] bArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return new byte[0];.swift
}.swift
return ArraysKt___ArraysJvmKt.copyOfRange(bArr, intRange.getStart().intValue(), tr1.f(1, intRange));.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(double[] dArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(dArr, i, i2);.swift
reverse(dArr, i, i2);.swift
}.swift
public static final <K, V, M extends Map<? super K, ? super V>> M associateByTo(char[] cArr, M m, Function1<? super Character, ? extends K> function1, Function1<? super Character, ? extends V> function12) {.swift
for (char c : cArr) {.swift
m.put(function1.invoke(Character.valueOf(c)), function12.invoke(Character.valueOf(c)));.swift
}.swift
return m;.swift
}.swift
public static final <A extends Appendable> A joinTo(float[] fArr, A a, CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3, int i, CharSequence charSequence4, Function1<? super Float, ? extends CharSequence> function1) {.swift
a.append(charSequence2);.swift
int i2 = 0;.swift
for (float f : fArr) {.swift
i2++;.swift
if (i2 > 1) {.swift
a.append(charSequence);.swift
}.swift
if (i >= 0 && i2 > i) {.swift
break;.swift
}.swift
if (function1 = null) {.swift
a.append((CharSequence) function1.invoke(Float.valueOf(f)));.swift
} else {.swift
a.append(String.valueOf(f));.swift
}.swift
}.swift
if (i >= 0 && i2 > i) {.swift
a.append(charSequence4);.swift
}.swift
a.append(charSequence3);.swift
return a;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Long maxByOrNull(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex == 0) {.swift
return Long.valueOf(j);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Long.valueOf(j));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Long.valueOf(j2));.swift
if (comparable.compareTo(comparable2) < 0) {.swift
j = j2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final <R extends Comparable<? super R>> Long minByOrNull(long[] jArr, Function1<? super Long, ? extends R> function1) {.swift
if (jArr.length == 0) {.swift
return null;.swift
}.swift
long j = jArr[0];.swift
int lastIndex = getLastIndex(jArr);.swift
if (lastIndex == 0) {.swift
return Long.valueOf(j);.swift
}.swift
Comparable comparable = (Comparable) function1.invoke(Long.valueOf(j));.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
long j2 = jArr[i];.swift
Comparable comparable2 = (Comparable) function1.invoke(Long.valueOf(j2));.swift
if (comparable.compareTo(comparable2) > 0) {.swift
j = j2;.swift
comparable = comparable2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Long.valueOf(j);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Boolean reduceIndexedOrNull(boolean[] zArr, Function3<? super Integer, ? super Boolean, ? super Boolean, Boolean> function3) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
boolean z = zArr[0];.swift
int lastIndex = getLastIndex(zArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
z = function3.invoke(Integer.valueOf(i), Boolean.valueOf(z), Boolean.valueOf(zArr[i])).booleanValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Boolean.valueOf(z);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Boolean reduceOrNull(boolean[] zArr, Function2<? super Boolean, ? super Boolean, Boolean> function2) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
boolean z = zArr[0];.swift
int lastIndex = getLastIndex(zArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
z = function2.invoke(Boolean.valueOf(z), Boolean.valueOf(zArr[i])).booleanValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Boolean.valueOf(z);.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void shuffle(float[] fArr, Random random) {.swift
for (int lastIndex = getLastIndex(fArr); lastIndex > 0; lastIndex--) {.swift
int nextInt = random.nextInt(lastIndex + 1);.swift
float f = fArr[lastIndex];.swift
fArr[lastIndex] = fArr[nextInt];.swift
fArr[nextInt] = f;.swift
}.swift
}.swift
public static final List<Boolean> dropWhile(boolean[] zArr, Function1<? super Boolean, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
boolean z = false;.swift
for (boolean z2 : zArr) {.swift
if (z) {.swift
arrayList.add(Boolean.valueOf(z2));.swift
} else if (function1.invoke(Boolean.valueOf(z2)).booleanValue()) {.swift
arrayList.add(Boolean.valueOf(z2));.swift
z = true;.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final long first(long[] jArr, Function1<? super Long, Boolean> function1) {.swift
for (long j : jArr) {.swift
if (function1.invoke(Long.valueOf(j)).booleanValue()) {.swift
return j;.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
public static final short last(short[] sArr, Function1<? super Short, Boolean> function1) {.swift
int length = sArr.length - 1;.swift
if (length >= 0) {.swift
while (true) {.swift
int i = length - 1;.swift
short s = sArr[length];.swift
if (function1.invoke(Short.valueOf(s)).booleanValue()) {.swift
if (i < 0) {.swift
break;.swift
}.swift
length = i;.swift
} else {.swift
return s;.swift
}.swift
}.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWithOrNull(boolean[] zArr, Comparator<? super R> comparator, Function1<? super Boolean, ? extends R> function1) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Boolean.valueOf(zArr[0]));.swift
int lastIndex = getLastIndex(zArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Boolean.valueOf(zArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double maxWithOrNull(double[] dArr, Comparator<? super Double> comparator) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
double d2 = dArr[i];.swift
if (comparator.compare(Double.valueOf(d), Double.valueOf(d2)) < 0) {.swift
d = d2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(d);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWithOrNull(boolean[] zArr, Comparator<? super R> comparator, Function1<? super Boolean, ? extends R> function1) {.swift
if (zArr.length == 0) {.swift
return null;.swift
}.swift
R invoke = function1.invoke(Boolean.valueOf(zArr[0]));.swift
int lastIndex = getLastIndex(zArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Boolean.valueOf(zArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final Double minWithOrNull(double[] dArr, Comparator<? super Double> comparator) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
double d2 = dArr[i];.swift
if (comparator.compare(Double.valueOf(d), Double.valueOf(d2)) > 0) {.swift
d = d2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(d);.swift
}.swift
public static final Pair<List<Float>, List<Float>> partition(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
ArrayList arrayList = new ArrayList();.swift
ArrayList arrayList2 = new ArrayList();.swift
for (float f : fArr) {.swift
if (function1.invoke(Float.valueOf(f)).booleanValue()) {.swift
arrayList.add(Float.valueOf(f));.swift
} else {.swift
arrayList2.add(Float.valueOf(f));.swift
}.swift
}.swift
return new Pair<>(arrayList, arrayList2);.swift
}.swift
public static final boolean reduce(boolean[] zArr, Function2<? super Boolean, ? super Boolean, Boolean> function2) {.swift
if (zArr.length = 0) {.swift
boolean z = zArr[0];.swift
int lastIndex = getLastIndex(zArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
z = function2.invoke(Boolean.valueOf(z), Boolean.valueOf(zArr[i])).booleanValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return z;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final boolean reduceIndexed(boolean[] zArr, Function3<? super Integer, ? super Boolean, ? super Boolean, Boolean> function3) {.swift
if (zArr.length = 0) {.swift
boolean z = zArr[0];.swift
int lastIndex = getLastIndex(zArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
z = function3.invoke(Integer.valueOf(i), Boolean.valueOf(z), Boolean.valueOf(zArr[i])).booleanValue();.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return z;.swift
}.swift
throw new UnsupportedOperationException("Empty array can't be reduced.");.swift
}.swift
public static final void reverse(boolean[] zArr) {.swift
int length = (zArr.length / 2) - 1;.swift
if (length >= 0) {.swift
int lastIndex = getLastIndex(zArr);.swift
if (length >= 0) {.swift
int i = 0;.swift
while (true) {.swift
boolean z = zArr[i];.swift
zArr[i] = zArr[lastIndex];.swift
zArr[lastIndex] = z;.swift
lastIndex--;.swift
if (i = length) {.swift
i++;.swift
} else {.swift
return;.swift
}.swift
}.swift
}.swift
}.swift
}.swift
/* JADX WARNING: type inference failed for: r6v0, types: [kotlin.jvm.functions.Function2, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Boolean, ? extends R>] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFold(boolean[] r4, R r5, kotlin.jvm.functions.Function2<? super R, ? super java.lang.Boolean, ? extends R> r6) {.swift
/*.swift
int r0 = r4.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r4 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r5).swift
return r4.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r4.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r5).swift
int r1 = r4.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x0027.swift
boolean r3 = r4[r2].swift
java.lang.Boolean r3 = java.lang.Boolean.valueOf(r3).swift
java.lang.Object r5 = r6.invoke(r5, r3).swift
r0.add(r5).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x0027:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFold(boolean[], java.lang.Object, kotlin.jvm.functions.Function2):java.util.List");.swift
}.swift
/* JADX WARNING: type inference failed for: r7v0, types: [kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Boolean, ? extends R>, kotlin.jvm.functions.Function3] */.swift
/* JADX WARNING: Unknown variable types count: 1 */.swift
@kotlin.SinceKotlin(version = "1.4").swift
@kotlin.internal.InlineOnly.swift
/* Code decompiled incorrectly, please refer to instructions dump. */.swift
private static final <R> java.util.List<R> runningFoldIndexed(boolean[] r5, R r6, kotlin.jvm.functions.Function3<? super java.lang.Integer, ? super R, ? super java.lang.Boolean, ? extends R> r7) {.swift
/*.swift
int r0 = r5.length.swift
if (r0 = 0) goto L_0x0008.swift
java.util.List r5 = kotlin.collections.CollectionsKt__CollectionsJVMKt.listOf(r6).swift
return r5.swift
L_0x0008:.swift
java.util.ArrayList r0 = new java.util.ArrayList.swift
int r1 = r5.length.swift
int r1 = r1 + 1.swift
r0.<init>(r1).swift
r0.add(r6).swift
int r1 = r5.length.swift
r2 = 0.swift
L_0x0015:.swift
if (r2 >= r1) goto L_0x002b.swift
java.lang.Integer r3 = java.lang.Integer.valueOf(r2).swift
boolean r4 = r5[r2].swift
java.lang.Boolean r4 = java.lang.Boolean.valueOf(r4).swift
java.lang.Object r6 = r7.invoke(r3, r6, r4).swift
r0.add(r6).swift
int r2 = r2 + 1.swift
goto L_0x0015.swift
L_0x002b:.swift
return r0.swift
*/.swift
throw new UnsupportedOperationException("Method not decompiled: kotlin.collections.ArraysKt___ArraysKt.runningFoldIndexed(boolean[], java.lang.Object, kotlin.jvm.functions.Function3):java.util.List");.swift
}.swift
@SinceKotlin(version = "1.4").swift
public static final void sortDescending(char[] cArr, int i, int i2) {.swift
ArraysKt___ArraysJvmKt.sort(cArr, i, i2);.swift
reverse(cArr, i, i2);.swift
}.swift
public static final <R, V> List<V> zip(short[] sArr, Iterable<? extends R> iterable, Function2<? super Short, ? super R, ? extends V> function2) {.swift
int length = sArr.length;.swift
ArrayList arrayList = new ArrayList(Math.min(CollectionsKt__IterablesKt.collectionSizeOrDefault(iterable, 10), length));.swift
int i = 0;.swift
for (Object next : iterable) {.swift
if (i >= length) {.swift
break;.swift
}.swift
arrayList.add(function2.invoke(Short.valueOf(sArr[i]), next));.swift
i++;.swift
}.swift
return arrayList;.swift
}.swift
public static final <T, K, V> Map<K, V> associateBy(T[] tArr, Function1<? super T, ? extends K> function1, Function1<? super T, ? extends V> function12) {.swift
LinkedHashMap linkedHashMap = new LinkedHashMap(RangesKt.coerceAtLeast(MapsKt__MapsJVMKt.mapCapacity(tArr.length), 16));.swift
for (T t : tArr) {.swift
linkedHashMap.put(function1.invoke(t), function12.invoke(t));.swift
}.swift
return linkedHashMap;.swift
}.swift
public static final <K> List<Double> distinctBy(double[] dArr, Function1<? super Double, ? extends K> function1) {.swift
HashSet hashSet = new HashSet();.swift
ArrayList arrayList = new ArrayList();.swift
for (double d : dArr) {.swift
if (hashSet.add(function1.invoke(Double.valueOf(d)))) {.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
}.swift
return arrayList;.swift
}.swift
public static final List<Long> drop(long[] jArr, int i) {.swift
if (i >= 0) {.swift
return takeLast(jArr, RangesKt.coerceAtLeast(jArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final List<Long> dropLast(long[] jArr, int i) {.swift
if (i >= 0) {.swift
return take(jArr, RangesKt.coerceAtLeast(jArr.length - i, 0));.swift
}.swift
throw new IllegalArgumentException(a81.j(i, "Requested element count ", " is less than zero.").toString());.swift
}.swift
public static final <K, M extends Map<? super K, List<Long>>> M groupByTo(long[] jArr, M m, Function1<? super Long, ? extends K> function1) {.swift
for (long j : jArr) {.swift
Object invoke = function1.invoke(Long.valueOf(j));.swift
Object obj = m.get(invoke);.swift
if (obj == null) {.swift
obj = tr1.r(m, invoke);.swift
}.swift
((List) obj).add(Long.valueOf(j));.swift
}.swift
return m;.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double maxOf(double[] dArr, Function1<? super Double, Double> function1) {.swift
if (dArr.length = 0) {.swift
double doubleValue = function1.invoke(Double.valueOf(dArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Double.valueOf(dArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: maxOfOrNull  reason: collision with other method in class */.swift
private static final Double m398maxOfOrNull(double[] dArr, Function1<? super Double, Double> function1) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Double.valueOf(dArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.max(doubleValue, function1.invoke(Double.valueOf(dArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R maxOfWith(double[] dArr, Comparator<? super R> comparator, Function1<? super Double, ? extends R> function1) {.swift
if (dArr.length = 0) {.swift
R invoke = function1.invoke(Double.valueOf(dArr[0]));.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Double.valueOf(dArr[i]));.swift
if (comparator.compare(invoke, invoke2) < 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "maxWithOrThrow").swift
public static final double maxWithOrThrow(double[] dArr, Comparator<? super Double> comparator) {.swift
if (dArr.length = 0) {.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
double d2 = dArr[i];.swift
if (comparator.compare(Double.valueOf(d), Double.valueOf(d2)) < 0) {.swift
d = d2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return d;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final double minOf(double[] dArr, Function1<? super Double, Double> function1) {.swift
if (dArr.length = 0) {.swift
double doubleValue = function1.invoke(Double.valueOf(dArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Double.valueOf(dArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return doubleValue;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
/* renamed from: minOfOrNull  reason: collision with other method in class */.swift
private static final Double m434minOfOrNull(double[] dArr, Function1<? super Double, Double> function1) {.swift
if (dArr.length == 0) {.swift
return null;.swift
}.swift
double doubleValue = function1.invoke(Double.valueOf(dArr[0])).doubleValue();.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
doubleValue = Math.min(doubleValue, function1.invoke(Double.valueOf(dArr[i])).doubleValue());.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return Double.valueOf(doubleValue);.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final <R> R minOfWith(double[] dArr, Comparator<? super R> comparator, Function1<? super Double, ? extends R> function1) {.swift
if (dArr.length = 0) {.swift
R invoke = function1.invoke(Double.valueOf(dArr[0]));.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
R invoke2 = function1.invoke(Double.valueOf(dArr[i]));.swift
if (comparator.compare(invoke, invoke2) > 0) {.swift
invoke = invoke2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return invoke;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.7").swift
@JvmName(name = "minWithOrThrow").swift
public static final double minWithOrThrow(double[] dArr, Comparator<? super Double> comparator) {.swift
if (dArr.length = 0) {.swift
double d = dArr[0];.swift
int lastIndex = getLastIndex(dArr);.swift
int i = 1;.swift
if (1 <= lastIndex) {.swift
while (true) {.swift
double d2 = dArr[i];.swift
if (comparator.compare(Double.valueOf(d), Double.valueOf(d2)) > 0) {.swift
d = d2;.swift
}.swift
if (i == lastIndex) {.swift
break;.swift
}.swift
i++;.swift
}.swift
}.swift
return d;.swift
}.swift
throw new NoSuchElementException();.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Double> runningReduce(double[] dArr, Function2<? super Double, ? super Double, Double> function2) {.swift
if (dArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
double d = dArr[0];.swift
ArrayList arrayList = new ArrayList(dArr.length);.swift
arrayList.add(Double.valueOf(d));.swift
int length = dArr.length;.swift
for (int i = 1; i < length; i++) {.swift
d = function2.invoke(Double.valueOf(d), Double.valueOf(dArr[i])).doubleValue();.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
return arrayList;.swift
}.swift
@SinceKotlin(version = "1.4").swift
@InlineOnly.swift
private static final List<Double> runningReduceIndexed(double[] dArr, Function3<? super Integer, ? super Double, ? super Double, Double> function3) {.swift
if (dArr.length == 0) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
double d = dArr[0];.swift
ArrayList arrayList = new ArrayList(dArr.length);.swift
arrayList.add(Double.valueOf(d));.swift
int length = dArr.length;.swift
for (int i = 1; i < length; i++) {.swift
d = function3.invoke(Integer.valueOf(i), Double.valueOf(d), Double.valueOf(dArr[i])).doubleValue();.swift
arrayList.add(Double.valueOf(d));.swift
}.swift
return arrayList;.swift
}.swift
public static final <T> T single(T[] tArr, Function1<? super T, Boolean> function1) {.swift
T t = null;.swift
boolean z = false;.swift
for (T t2 : tArr) {.swift
if (function1.invoke(t2).booleanValue()) {.swift
if (z) {.swift
z = true;.swift
t = t2;.swift
} else {.swift
throw new IllegalArgumentException("Array contains more than one matching element.");.swift
}.swift
}.swift
}.swift
if (z) {.swift
return t;.swift
}.swift
throw new NoSuchElementException("Array contains no element matching the predicate.");.swift
}.swift
public static final List<Double> slice(double[] dArr, IntRange intRange) {.swift
if (intRange.isEmpty()) {.swift
return CollectionsKt__CollectionsKt.emptyList();.swift
}.swift
return ArraysKt___ArraysJvmKt.asList(ArraysKt___ArraysJvmKt.copyOfRange(dArr, intRange.getStart().intValue(), tr1.f(1, intRange)));.swift
}.swift
@OverloadResolutionByLambdaReturnType.swift
@SinceKotlin(version = "1.5").swift
@InlineOnly.swift
@WasExperimental(markerClass = {ExperimentalUnsignedTypes.class}).swift
@JvmName(name = "sumOfUInt").swift
private static final int sumOfUInt(double[] dArr, Function1<? super Double, UInt> function1) {.swift
int r1 = UInt.m118constructorimpl(0);.swift
for (double valueOf : dArr) {.swift
r1 = tr1.g(function1.invoke(Double.valueOf(valueOf)), r1);.swift
}.swift
return r1;.swift
}.swift
public static final float first(float[] fArr, Function1<? super Float, Boolean> function1) {.swift
